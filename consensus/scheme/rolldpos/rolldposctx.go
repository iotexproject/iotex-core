// Copyright (c) 2018 IoTeX
// This is an alpha (internal) release and is not suitable for production. This source code is provided 'as is' and no
// warranties are given as to title or non-infringement, merchantability or fitness for purpose and, to the extent
// permitted by law, all liability for your use of the code is disclaimed. This source code is governed by Apache
// License 2.0 that can be found in the LICENSE file.

package rolldpos

import (
	"bytes"
	"encoding/hex"
	"sync"
	"time"

	"github.com/facebookgo/clock"
	"github.com/pkg/errors"
	"github.com/rs/zerolog"
	"github.com/zjshen14/go-fsm"

	"github.com/iotexproject/iotex-core/action"
	"github.com/iotexproject/iotex-core/actpool"
	"github.com/iotexproject/iotex-core/blockchain"
	"github.com/iotexproject/iotex-core/blockchain/block"
	"github.com/iotexproject/iotex-core/config"
	"github.com/iotexproject/iotex-core/consensus/fsm"
	"github.com/iotexproject/iotex-core/consensus/scheme"
	"github.com/iotexproject/iotex-core/crypto"
	"github.com/iotexproject/iotex-core/endorsement"
	"github.com/iotexproject/iotex-core/explorer/idl/explorer"
	"github.com/iotexproject/iotex-core/iotxaddress"
	"github.com/iotexproject/iotex-core/logger"
	"github.com/iotexproject/iotex-core/pkg/hash"
	"github.com/iotexproject/iotex-core/proto"
	"github.com/iotexproject/iotex-core/state"
)

// epochCtx keeps the context data for the current epoch
type epochCtx struct {
	// num is the ordinal number of an epoch
	num uint64
	// height means offset for current epochStart (i.e., the height of the first block generated in this epochStart)
	height uint64
	// numSubEpochs defines number of sub-epochs/rotations will happen in an epochStart
	numSubEpochs uint
	// subEpochNum is the ordinal number of sub-epoch within the current epoch
	subEpochNum uint64
	// secrets are the dkg secrets sent from current node to other delegates
	secrets [][]uint32
	// witness is the dkg secret witness sent from current node to other delegates
	witness [][]byte
	// committedSecrets are the secret shares within the secret blocks committed by current node
	committedSecrets map[string][]uint32
	delegates        []string
	dkgAddress       iotxaddress.DKGAddress
	seed             []byte
}

// roundCtx keeps the context data for the current round and block.
type roundCtx struct {
	height          uint64
	number          uint32
	proofOfLock     *endorsement.Set
	timestamp       time.Time
	block           consensusfsm.Endorsement
	endorsementSets map[string]*endorsement.Set
	proposer        string
}

type rollDPoSCtx struct {
	cfg              config.RollDPoS
	addr             *iotxaddress.Address
	chain            blockchain.Blockchain
	actPool          actpool.ActPool
	broadcastHandler scheme.Broadcast
	epoch            epochCtx
	round            roundCtx
	clock            clock.Clock
	rootChainAPI     explorer.Explorer
	// candidatesByHeightFunc is only used for testing purpose
	candidatesByHeightFunc func(uint64) ([]*state.Candidate, error)
	mutex                  sync.RWMutex
}

func (ctx *rollDPoSCtx) ReadyToCommit() bool {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()
	if ctx.round.proofOfLock == nil {
		return false
	}
	return ctx.hasEnoughEndorsements(
		ctx.round.proofOfLock.BlockHash(),
		map[endorsement.ConsensusVoteTopic]bool{
			endorsement.COMMIT: true,
		},
	)
}

func (ctx *rollDPoSCtx) OnConsensusReached() {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()
	ctx.Logger().Info().
		Uint64("blockHeight", ctx.round.height).
		Msg("consensus reached")
	pendingBlock := ctx.round.block.(*blockWrapper)
	// If the pending block is a secret block, record the secret share generated by producer
	if ctx.shouldHandleDKG() {
		for _, secretProposal := range pendingBlock.SecretProposals {
			if secretProposal.DstAddr() == ctx.addr.RawAddress {
				ctx.epoch.committedSecrets[secretProposal.SrcAddr()] = secretProposal.Secret()
				break
			}
		}
	}
	// Commit and broadcast the pending block
	if err := ctx.chain.CommitBlock(pendingBlock.Block); err != nil {
		logger.Error().
			Err(err).
			Uint64("block", pendingBlock.Height()).
			Msg("error when committing a block")
	}
	// Remove transfers in this block from ActPool and reset ActPool state
	ctx.actPool.Reset()
	// Broadcast the committed block to the network
	if blkProto := pendingBlock.ConvertToBlockPb(); blkProto != nil {
		if err := ctx.broadcastHandler(blkProto); err != nil {
			logger.Error().
				Err(err).
				Uint64("block", pendingBlock.Height()).
				Msg("error when broadcasting blkProto")
		}
		// putblock to parent chain if the current node is proposer and current chain is a sub chain
		if ctx.round.proposer == ctx.addr.RawAddress && ctx.chain.ChainAddress() != "" {
			putBlockToParentChain(ctx.rootChainAPI, ctx.chain.ChainAddress(), ctx.addr, pendingBlock.Block)
		}
	} else {
		logger.Error().
			Uint64("block", pendingBlock.Height()).
			Msg("error when converting a block into a proto msg")
	}
}

func (ctx *rollDPoSCtx) MintBlock() (consensusfsm.Endorsement, error) {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()
	if blk := ctx.round.block; blk != nil {
		blk.(*blockWrapper).round = ctx.round.number
		return blk, nil
	}
	blk, err := ctx.mintBlock()
	if err != nil {
		return nil, err
	}

	return &blockWrapper{
		blk,
		ctx.round.number,
	}, nil
}

func (ctx *rollDPoSCtx) NewConsensusEvent(
	eventType fsm.EventType,
	data interface{},
) *consensusfsm.ConsensusEvent {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	return ctx.newConsensusEvent(eventType, data)
}

func (ctx *rollDPoSCtx) NewBackdoorEvt(
	dst fsm.State,
) *consensusfsm.ConsensusEvent {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	return ctx.newConsensusEvent(consensusfsm.BackdoorEvent, dst)
}

func (ctx *rollDPoSCtx) Logger() *zerolog.Logger {
	return logger.Logger()
}

func (ctx *rollDPoSCtx) LoggerWithStats() *zerolog.Logger {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	return ctx.loggerWithStats()
}

func (ctx *rollDPoSCtx) NewProposalEndorsement(en consensusfsm.Endorsement) (consensusfsm.Endorsement, error) {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	blk, ok := en.(*blockWrapper)
	if !ok {
		return nil, errors.New("invalid block")
	}
	// TODO: delete the following check
	if blk.Height() != ctx.round.height {
		return nil, errors.Errorf(
			"unexpected block height %d, %d expected",
			blk.Height(),
			ctx.round.height,
		)
	}
	producer := blk.Endorser()
	expectedProposer := ctx.round.proposer
	if producer == "" || producer != expectedProposer {
		return nil, errors.Errorf(
			"unexpected block proposer %s, %s expected",
			producer,
			ctx.round.proposer,
		)
	}
	if producer != ctx.round.proposer || blk.WorkingSet == nil {
		containCoinbase := true
		if ctx.cfg.EnableDKG {
			if ctx.shouldHandleDKG() {
				containCoinbase = false
			} else if err := verifyDKGSignature(blk.Block, ctx.epoch.seed); err != nil {
				// Verify dkg signature failed
				return nil, errors.Wrapf(err, "failed to verify the DKG signature")
			}
		}
		if err := ctx.chain.ValidateBlock(blk.Block, containCoinbase); err != nil {
			return nil, errors.Wrapf(err, "error when validating the proposed block")
		}
	}
	ctx.round.block = blk

	return ctx.newEndorsement(endorsement.PROPOSAL)
}

func (ctx *rollDPoSCtx) HasReceivedBlock() bool {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	return ctx.round.block != nil
}

func (ctx *rollDPoSCtx) NewLockEndorsement() (consensusfsm.Endorsement, error) {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	return ctx.newEndorsement(endorsement.LOCK)
}

func (ctx *rollDPoSCtx) NewPreCommitEndorsement() (consensusfsm.Endorsement, error) {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	return ctx.newEndorsement(endorsement.COMMIT)
}

func (ctx *rollDPoSCtx) AddProposalEndorsement(en consensusfsm.Endorsement) error {
	ctx.mutex.Lock()
	defer ctx.mutex.Unlock()

	expectedTopics := map[endorsement.ConsensusVoteTopic]bool{
		endorsement.PROPOSAL: true,
		endorsement.COMMIT:   true, // commit endorse is counted as one proposal endorse
	}
	if err := ctx.processEndorsement(en, expectedTopics); err != nil {
		return err
	}

	hash := en.Hash()
	if ctx.hasEnoughEndorsements(hash, expectedTopics) {
		// TODO: handle the case of multiple prooves of lock
		ctx.round.proofOfLock = ctx.round.endorsementSets[hex.EncodeToString(hash)]
	}

	return nil
}

func (ctx *rollDPoSCtx) IsLocked() bool {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	return ctx.round.proofOfLock != nil
}

func (ctx *rollDPoSCtx) AddLockEndorsement(en consensusfsm.Endorsement) error {
	ctx.mutex.Lock()
	defer ctx.mutex.Unlock()

	return ctx.processEndorsement(
		en,
		map[endorsement.ConsensusVoteTopic]bool{
			endorsement.LOCK:   true,
			endorsement.COMMIT: true, // commit endorse is counted as one proposal endorse
		},
	)
}

func (ctx *rollDPoSCtx) ReadyToPreCommit() bool {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	if ctx.round.proofOfLock == nil {
		return false
	}

	return ctx.hasEnoughEndorsements(
		ctx.round.proofOfLock.BlockHash(),
		map[endorsement.ConsensusVoteTopic]bool{
			endorsement.LOCK:   true,
			endorsement.COMMIT: true, // commit endorse is counted as one proposal endorse
		},
	)
}

func (ctx *rollDPoSCtx) AddPreCommitEndorsement(en consensusfsm.Endorsement) error {
	ctx.mutex.Lock()
	defer ctx.mutex.Unlock()

	return ctx.processEndorsement(
		en,
		map[endorsement.ConsensusVoteTopic]bool{
			endorsement.COMMIT: true, // commit endorse is counted as one proposal endorse
		},
	)
}

func (ctx *rollDPoSCtx) BroadcastBlockProposal(block consensusfsm.Endorsement) {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	data, err := block.Serialize()
	if err != nil {
		ctx.loggerWithStats().Panic().Err(err).Msg("Failed to serialize block")
	}
	if err := ctx.broadcastHandler(&iproto.ConsensusPb{
		Height:    ctx.round.height,
		Round:     ctx.round.number,
		Type:      iproto.ConsensusPb_PROPOSAL,
		Data:      data,
		Timestamp: uint64(ctx.clock.Now().Unix()),
	}); err != nil {
		ctx.loggerWithStats().Error().Err(err).Msg("fail to broadcast block")
	}
}

func (ctx *rollDPoSCtx) BroadcastEndorsement(en consensusfsm.Endorsement) {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	data, err := en.Serialize()
	if err != nil {
		ctx.loggerWithStats().Panic().Err(err).Msg("Failed to serialize endorsement")
	}
	if err := ctx.broadcastHandler(&iproto.ConsensusPb{
		Height:    ctx.round.height,
		Round:     ctx.round.number,
		Type:      iproto.ConsensusPb_ENDORSEMENT,
		Data:      data,
		Timestamp: uint64(ctx.clock.Now().Unix()),
	}); err != nil {
		ctx.loggerWithStats().Error().Err(err).Msg("fail to broadcast endorsement")
	}
}

func (ctx *rollDPoSCtx) IsStaleEvent(evt *consensusfsm.ConsensusEvent) bool {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	return evt.Height() < ctx.round.height ||
		evt.Height() == ctx.round.height && evt.Round() < ctx.round.number
}

func (ctx *rollDPoSCtx) IsFutureEvent(evt *consensusfsm.ConsensusEvent) bool {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	return evt.Height() > ctx.round.height ||
		evt.Height() == ctx.round.height && evt.Round() > ctx.round.number
}

func (ctx *rollDPoSCtx) IsStaleUnmatchedEvent(evt *consensusfsm.ConsensusEvent) bool {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	return ctx.clock.Now().Sub(evt.Timestamp()) > ctx.cfg.FSM.UnmatchedEventTTL
}

func (ctx *rollDPoSCtx) IsDelegate() bool {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	return ctx.isDelegate()
}

func (ctx *rollDPoSCtx) IsProposer() bool {
	ctx.mutex.RLock()
	defer ctx.mutex.RUnlock()

	return ctx.isProposer()
}

///////////////////////////////////////////
// private functions
///////////////////////////////////////////

func (ctx *rollDPoSCtx) hasEnoughEndorsements(
	hash []byte,
	expectedTopics map[endorsement.ConsensusVoteTopic]bool,
) bool {
	set, ok := ctx.round.endorsementSets[hex.EncodeToString(hash)]
	if !ok {
		return false
	}
	validNum := set.NumOfValidEndorsements(
		expectedTopics,
		ctx.epoch.delegates,
	)
	numDelegates := len(ctx.epoch.delegates)
	return numDelegates >= 4 && validNum > numDelegates*2/3 ||
		numDelegates < 4 && validNum >= numDelegates
}

func (ctx *rollDPoSCtx) newConsensusEvent(
	eventType fsm.EventType,
	data interface{},
) *consensusfsm.ConsensusEvent {
	return consensusfsm.NewConsensusEvent(
		eventType,
		data,
		ctx.round.height,
		ctx.round.number,
		ctx.clock.Now(),
	)
}

func (ctx *rollDPoSCtx) calcWaitDuration() (time.Duration, error) {
	// TODO: Update wait duration calculation algorithm
	// If the proposal interval is not set (not zero), the next round will only be started after the configured duration
	// after last block's creation time, so that we could keep the constant
	waitDuration := time.Duration(0)
	// If we have the cached last block, we get the timestamp from it
	duration, err := ctx.calcDurationSinceLastBlock()
	if err != nil {
		return waitDuration, err
	}
	interval := ctx.cfg.FSM.ProposerInterval
	if interval > 0 {
		waitDuration = (interval - (duration % interval)) % interval
	}

	return waitDuration, nil
}

func (ctx *rollDPoSCtx) loggerWithStats() *zerolog.Logger {
	numProposals := 0
	numLocks := 0
	numCommits := 0
	if ctx.round.block != nil {
		blkHashHex := hex.EncodeToString(ctx.round.block.Hash())
		endorsementSet := ctx.round.endorsementSets[blkHashHex]
		if endorsementSet != nil {
			numProposals = endorsementSet.NumOfValidEndorsements(
				map[endorsement.ConsensusVoteTopic]bool{
					endorsement.PROPOSAL: true,
					endorsement.COMMIT:   true,
				},
				ctx.epoch.delegates,
			)
			numLocks = endorsementSet.NumOfValidEndorsements(
				map[endorsement.ConsensusVoteTopic]bool{
					endorsement.LOCK:   true,
					endorsement.COMMIT: true,
				},
				ctx.epoch.delegates,
			)
			numCommits = endorsementSet.NumOfValidEndorsements(
				map[endorsement.ConsensusVoteTopic]bool{
					endorsement.COMMIT: true,
				},
				ctx.epoch.delegates,
			)
		}
	}
	ctxl := logger.With().
		Uint64("height", ctx.round.height).
		Uint32("round", ctx.round.number).
		Int("numProposals", numProposals).
		Int("numLocks", numLocks).
		Int("numCommits", numCommits).
		Logger()

	return &ctxl
}

func (ctx *rollDPoSCtx) newEndorsement(topic endorsement.ConsensusVoteTopic) (consensusfsm.Endorsement, error) {
	endorsement := endorsement.NewEndorsement(
		endorsement.NewConsensusVote(
			ctx.round.block.Hash(),
			ctx.round.height,
			ctx.round.number,
			topic,
		),
		ctx.addr,
	)

	return &endorsementWrapper{endorsement}, nil
}

func (ctx *rollDPoSCtx) isProposedBlock(hash []byte) bool {
	if ctx.round.block == nil {
		logger.Error().Msg("block is nil")
		return false
	}
	blkHash := ctx.round.block.Hash()

	return bytes.Equal(hash, blkHash)
}

func (ctx *rollDPoSCtx) isDelegateEndorsement(endorser string) bool {
	for _, delegate := range ctx.epoch.delegates {
		if delegate == endorser {
			return true
		}
	}
	return false
}

func (ctx *rollDPoSCtx) processEndorsement(
	en consensusfsm.Endorsement,
	expectedTopics map[endorsement.ConsensusVoteTopic]bool,
) error {
	endorse, ok := en.(*endorsementWrapper)
	if !ok {
		return errors.New("invalid endorsement")
	}
	vote := endorse.ConsensusVote()
	if !ctx.isProposedBlock(vote.BlkHash) {
		return errors.New("the endorsed block was not the proposed block")
	}
	if !ctx.isDelegateEndorsement(endorse.Endorser()) {
		return errors.Errorf("invalid endorser %s", endorse.Endorser())
	}
	if _, ok := expectedTopics[vote.Topic]; !ok {
		return errors.Errorf("invalid consensus topic %s", vote.Topic)
	}
	if vote.Height != ctx.round.height {
		return errors.Errorf(
			"invalid endorsement height %d, %d expected",
			vote.Height,
			ctx.round.height,
		)
	}
	blkHashHex := hex.EncodeToString(vote.BlkHash)
	endorsementSet, ok := ctx.round.endorsementSets[blkHashHex]
	if !ok {
		endorsementSet = endorsement.NewSet(vote.BlkHash)
		ctx.round.endorsementSets[blkHashHex] = endorsementSet
	}

	return endorsementSet.AddEndorsement(endorse.Endorsement)
}

func (ctx *rollDPoSCtx) updateSeedAndRollingDelegates(epochNum uint64) ([]string, error) {
	// Update CryptoSort seed
	// TODO: Consider persist the most recent seed
	var err error
	if !ctx.cfg.EnableDKG {
		ctx.epoch.seed = crypto.CryptoSeed
	} else if ctx.epoch.seed, err = ctx.updateSeed(); err != nil {
		logger.Error().Err(err).Msg("Failed to generate new seed from last epoch")
	}

	return ctx.rollingDelegates(epochNum)
}

// rollingDelegates will only allows the delegates chosen for given epoch to enter the epoch
func (ctx *rollDPoSCtx) rollingDelegates(epochNum uint64) ([]string, error) {
	numDlgs := ctx.cfg.NumDelegates
	height := uint64(numDlgs) * uint64(ctx.cfg.NumSubEpochs) * (epochNum - 1)
	var err error
	var candidates []*state.Candidate
	if ctx.candidatesByHeightFunc != nil {
		// Test only
		candidates, err = ctx.candidatesByHeightFunc(height)
	} else {
		candidates, err = ctx.chain.CandidatesByHeight(height)
	}
	if err != nil {
		return []string{}, errors.Wrap(err, "error when getting delegates from the candidate pool")
	}
	if len(candidates) < int(numDlgs) {
		return []string{}, errors.Wrapf(ErrNotEnoughCandidates, "only %d delegates from the candidate pool", len(candidates))
	}

	candidatesAddress := []string{}
	for _, candidate := range candidates {
		candidatesAddress = append(candidatesAddress, candidate.Address)
	}
	crypto.SortCandidates(candidatesAddress, epochNum, ctx.epoch.seed)

	return candidatesAddress[:numDlgs], nil
}

// calcEpochNum calculates the epoch ordinal number and the epoch start height offset, which is based on the height of
// the next block to be produced
func (ctx *rollDPoSCtx) calcEpochNumAndHeight() (uint64, uint64) {
	height := ctx.chain.TipHeight()
	numDlgs := ctx.cfg.NumDelegates
	numSubEpochs := ctx.getNumSubEpochs()
	epochNum := height/(uint64(numDlgs)*uint64(numSubEpochs)) + 1
	epochHeight := uint64(numDlgs)*uint64(numSubEpochs)*(epochNum-1) + 1
	return epochNum, epochHeight
}

// calcSubEpochNum calculates the sub-epoch ordinal number
func (ctx *rollDPoSCtx) calcSubEpochNum() (uint64, error) {
	height := ctx.chain.TipHeight() + 1
	if height < ctx.epoch.height {
		return 0, errors.New("Tip height cannot be less than epoch height")
	}
	numDlgs := ctx.cfg.NumDelegates
	subEpochNum := (height - ctx.epoch.height) / uint64(numDlgs)
	return subEpochNum, nil
}

// shouldHandleDKG indicates whether a node is in DKG stage
func (ctx *rollDPoSCtx) shouldHandleDKG() bool {
	if !ctx.cfg.EnableDKG {
		return false
	}
	return ctx.epoch.subEpochNum == 0
}

// generateDKGSecrets generates DKG secrets and witness
func (ctx *rollDPoSCtx) generateDKGSecrets() ([][]uint32, [][]byte, error) {
	idList := make([][]uint8, 0)
	for _, addr := range ctx.epoch.delegates {
		dkgID := iotxaddress.CreateID(addr)
		idList = append(idList, dkgID)
		if addr == ctx.addr.RawAddress {
			ctx.epoch.dkgAddress = iotxaddress.DKGAddress{ID: dkgID}
		}
	}
	_, secrets, witness, err := crypto.DKG.Init(crypto.DKG.SkGeneration(), idList)
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to generate DKG Secrets and Witness")
	}
	return secrets, witness, nil
}

// TODO: numDlgs should also be configurable in BLS. For test purpose, let's make it 21.
// generateDKGKeyPair generates DKG key pair
func (ctx *rollDPoSCtx) generateDKGKeyPair() ([]byte, []uint32, error) {
	numDlgs := ctx.cfg.NumDelegates
	if numDlgs != 21 {
		return nil, nil, errors.New("Number of delegates must be 21 for test purpose")
	}
	shares := make([][]uint32, numDlgs)
	shareStatusMatrix := make([][21]bool, numDlgs)
	for i := range shares {
		shares[i] = make([]uint32, sigSize)
	}
	for i, delegate := range ctx.epoch.delegates {
		if secret, ok := ctx.epoch.committedSecrets[delegate]; ok {
			shares[i] = secret
			for j := 0; j < int(numDlgs); j++ {
				shareStatusMatrix[j][i] = true
			}
		}
	}
	_, dkgPubKey, dkgPriKey, err := crypto.DKG.KeyPairGeneration(shares, shareStatusMatrix)
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to generate DKG key pair")
	}
	return dkgPubKey, dkgPriKey, nil
}

// getNumSubEpochs returns max(configured number, 1)
func (ctx *rollDPoSCtx) getNumSubEpochs() uint {
	num := uint(1)
	if ctx.cfg.NumSubEpochs > 0 {
		num = ctx.cfg.NumSubEpochs
	}
	if ctx.cfg.EnableDKG {
		num++
	}
	return num
}

func (ctx *rollDPoSCtx) isDelegate() bool {
	for _, d := range ctx.epoch.delegates {
		if ctx.addr.RawAddress == d {
			return true
		}
	}

	return false
}

func (ctx *rollDPoSCtx) isProposer() bool {
	return ctx.round.proposer == ctx.addr.RawAddress
}

func (ctx *rollDPoSCtx) Prepare() (time.Duration, error) {
	ctx.mutex.Lock()
	defer ctx.mutex.Unlock()

	if ctx.shouldHandleDKG() && ctx.isDKGFinished() {
		dkgPubKey, dkgPriKey, err := ctx.generateDKGKeyPair()
		if err != nil {
			return time.Duration(0), errors.Wrap(
				err,
				"error when generating DKG key pair",
			)
		}
		ctx.epoch.dkgAddress.PublicKey = dkgPubKey
		ctx.epoch.dkgAddress.PrivateKey = dkgPriKey
	}
	epochNum, epochHeight := ctx.calcEpochNumAndHeight()
	if epochNum != ctx.epoch.num {
		delegates, err := ctx.updateSeedAndRollingDelegates(epochNum)
		if err != nil {
			// Even if error happens, we still need to schedule next check of delegate to tolerate transit error
			return ctx.cfg.DelegateInterval, errors.Wrap(
				err,
				"error when determining if the node will participate into next epoch",
			)
		}
		// The epochStart start height is going to be the next block to generate
		ctx.epoch.num = epochNum
		ctx.epoch.height = epochHeight
		ctx.epoch.delegates = delegates
		ctx.epoch.numSubEpochs = ctx.getNumSubEpochs()
		ctx.epoch.subEpochNum = uint64(0)
		ctx.epoch.committedSecrets = make(map[string][]uint32)
	}
	// If the current node is the delegate, move to the next state
	if !ctx.isDelegate() {
		return ctx.cfg.DelegateInterval, nil
	}
	logger.Info().
		Uint64("epoch", epochNum).
		Msg("current node is the delegate")
	if ctx.shouldHandleDKG() {
		// TODO: numDelegates will be configurable later on
		if len(ctx.epoch.delegates) != 21 {
			logger.Panic().Msg("Number of delegates is incorrect for DKG generation")
		}
		secrets, witness, err := ctx.generateDKGSecrets()
		if err != nil {
			return time.Duration(0), err
		}
		ctx.epoch.secrets = secrets
		ctx.epoch.witness = witness
	}
	waitDuration, err := ctx.calcWaitDuration()
	if err != nil {
		return waitDuration, err
	}
	subEpochNum, err := ctx.calcSubEpochNum()
	if err != nil {
		return waitDuration, err
	}
	ctx.epoch.subEpochNum = subEpochNum

	proposer, height, round, err := ctx.rotatedProposer(waitDuration)
	if err != nil {
		return waitDuration, err
	}
	if ctx.round.height != height {
		ctx.round = roundCtx{
			height:          height,
			endorsementSets: make(map[string]*endorsement.Set),
		}
	}
	ctx.round.number = round
	ctx.round.proposer = proposer
	ctx.round.timestamp = ctx.clock.Now()

	log := logger.Info().
		Str("proposer", ctx.round.proposer).
		Uint64("height", ctx.round.height).
		Uint32("round", ctx.round.number)
	if ctx.isProposer() {
		log.Msg("current node is the proposer")
	} else {
		log.Msg("current node is not the proposer")
	}
	return waitDuration, nil
}

// rotatedProposer will rotate among the delegates to choose the proposer. It is pseudo order based on the position
// in the delegate list and the block height
func (ctx *rollDPoSCtx) rotatedProposer(offsetDuration time.Duration) (
	proposer string,
	height uint64,
	round uint32,
	err error,
) {
	// Next block height
	height = ctx.chain.TipHeight() + 1
	round, proposer, err = ctx.calcProposer(height, ctx.epoch.delegates, offsetDuration)

	return proposer, height, round, err
}

// calcProposer calculates the proposer for the block at a given height
func (ctx *rollDPoSCtx) calcProposer(
	height uint64,
	delegates []string,
	offsetDuration time.Duration,
) (uint32, string, error) {
	numDelegates := len(delegates)
	if numDelegates == 0 {
		return 0, "", ErrZeroDelegate
	}
	timeSlotIndex := uint32(0)
	if ctx.cfg.FSM.ProposerInterval > 0 {
		duration, err := ctx.calcDurationSinceLastBlock()
		if err != nil || duration < 0 {
			if !ctx.cfg.TimeBasedRotation {
				return 0, delegates[(height)%uint64(numDelegates)], nil
			}
			return 0, "", errors.Wrap(err, "error when computing the duration since last block time")
		}
		duration += offsetDuration
		if duration > ctx.cfg.FSM.ProposerInterval {
			timeSlotIndex = uint32(duration/ctx.cfg.FSM.ProposerInterval) - 1
		}
	}
	if !ctx.cfg.TimeBasedRotation {
		return timeSlotIndex, delegates[(height)%uint64(numDelegates)], nil
	}
	// TODO: should downgrade to debug level in the future
	logger.Info().Uint32("slot", timeSlotIndex).Msg("calculate time slot offset")
	timeSlotMtc.WithLabelValues().Set(float64(timeSlotIndex))
	return timeSlotIndex, delegates[(height+uint64(timeSlotIndex))%uint64(numDelegates)], nil
}

// mintBlock mints a new block to propose
func (ctx *rollDPoSCtx) mintBlock() (*block.Block, error) {
	if ctx.shouldHandleDKG() {
		return ctx.mintSecretBlock()
	}
	return ctx.mintCommonBlock()
}

// mintSecretBlock collects DKG secret proposals and witness and creates a block to propose
func (ctx *rollDPoSCtx) mintSecretBlock() (*block.Block, error) {
	secrets := ctx.epoch.secrets
	witness := ctx.epoch.witness
	if len(secrets) != len(ctx.epoch.delegates) {
		return nil, errors.New("Number of secrets does not match number of delegates")
	}
	confirmedNonce, err := ctx.chain.Nonce(ctx.addr.RawAddress)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get the confirmed nonce of secret block producer")
	}
	nonce := confirmedNonce + 1
	secretProposals := make([]*action.SecretProposal, 0)
	for i, delegate := range ctx.epoch.delegates {
		secretProposal, err := action.NewSecretProposal(nonce, ctx.addr.RawAddress, delegate, secrets[i])
		if err != nil {
			return nil, errors.Wrap(err, "failed to create the secret proposal")
		}
		secretProposals = append(secretProposals, secretProposal)
		nonce++
	}
	secretWitness, err := action.NewSecretWitness(nonce, ctx.addr.RawAddress, witness)
	if err != nil {
		return nil, errors.Wrap(err, "failed to create the secret witness")
	}
	blk, err := ctx.chain.MintNewSecretBlock(secretProposals, secretWitness, ctx.addr)
	if err != nil {
		return nil, err
	}
	logger.Info().
		Uint64("height", blk.Height()).
		Int("secretProposals", len(blk.SecretProposals)).
		Msg("minted a new secret block")
	return blk, nil
}

// mintCommonBlock picks the actions and creates a common block to propose
func (ctx *rollDPoSCtx) mintCommonBlock() (*block.Block, error) {
	actions := ctx.actPool.PickActs()
	logger.Debug().
		Int("action", len(actions)).
		Msg("pick actions from the action pool")
	blk, err := ctx.chain.MintNewBlock(actions, ctx.addr, &ctx.epoch.dkgAddress,
		ctx.epoch.seed, "")
	if err != nil {
		return nil, err
	}
	logger.Info().
		Uint64("height", blk.Height()).
		Int("actions", len(blk.Actions)).
		Msg("minted a new block")
	return blk, nil
}

// calcDurationSinceLastBlock returns the duration since last block time
func (ctx *rollDPoSCtx) calcDurationSinceLastBlock() (time.Duration, error) {
	height := ctx.chain.TipHeight()
	blk, err := ctx.chain.GetBlockByHeight(height)
	if err != nil {
		return 0, errors.Wrapf(err, "error when getting the block at height: %d", height)
	}
	return ctx.clock.Now().Sub(time.Unix(blk.Header.Timestamp(), 0)), nil
}

// calcQuorum calculates if more than 2/3 vote yes or no including self's vote
func (ctx *rollDPoSCtx) calcQuorum(decisions map[string]bool) (bool, bool) {
	yes := 0
	no := 0
	for _, decision := range decisions {
		if decision {
			yes++
		} else {
			no++
		}
	}
	numDelegates := len(ctx.epoch.delegates)
	return yes >= numDelegates*2/3+1, no >= numDelegates*1/3
}

// isEpochFinished checks the epoch is finished or not
func (ctx *rollDPoSCtx) isEpochFinished() bool {
	height := ctx.chain.TipHeight()
	// if the height of the last committed block is already the last one should be minted from this epochStart, go back
	// to epochStart start
	if height >= ctx.epoch.height+uint64(uint(len(ctx.epoch.delegates))*ctx.epoch.numSubEpochs)-1 {
		return true
	}
	return false
}

// isDKGFinished checks the DKG sub-epoch is finished or not
func (ctx *rollDPoSCtx) isDKGFinished() bool {
	height := ctx.chain.TipHeight()
	return height >= ctx.epoch.height+uint64(len(ctx.epoch.delegates))-1
}

// updateSeed returns the seed for the next epoch
func (ctx *rollDPoSCtx) updateSeed() ([]byte, error) {
	epochNum, epochHeight := ctx.calcEpochNumAndHeight()
	if epochNum <= 1 {
		return crypto.CryptoSeed, nil
	}
	selectedID := make([][]uint8, 0)
	selectedSig := make([][]byte, 0)
	selectedPK := make([][]byte, 0)
	for h := uint64(ctx.cfg.NumDelegates)*uint64(ctx.cfg.NumSubEpochs)*(epochNum-2) + 1; h < epochHeight && len(selectedID) <= crypto.Degree; h++ {
		blk, err := ctx.chain.GetBlockByHeight(h)
		if err != nil {
			continue
		}
		if len(blk.DKGID()) > 0 && len(blk.DKGPubkey()) > 0 && len(blk.DKGSignature()) > 0 {
			selectedID = append(selectedID, blk.DKGID())
			selectedSig = append(selectedSig, blk.DKGSignature())
			selectedPK = append(selectedPK, blk.DKGPubkey())
		}
	}

	if len(selectedID) <= crypto.Degree {
		return hash.Hash256b(ctx.epoch.seed), errors.New("DKG signature/pubic key is not enough to aggregate")
	}

	aggregateSig, err := crypto.BLS.SignAggregate(selectedID, selectedSig)
	if err != nil {
		return hash.Hash256b(ctx.epoch.seed), errors.Wrap(err, "Failed to generate aggregate signature to update Seed")
	}
	if err = crypto.BLS.VerifyAggregate(selectedID, selectedPK, ctx.epoch.seed, aggregateSig); err != nil {
		return hash.Hash256b(ctx.epoch.seed), errors.Wrap(err, "Failed to verify aggregate signature to update Seed")
	}
	return aggregateSig, nil
}
