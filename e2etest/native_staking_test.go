package e2etest

import (
	"context"
	"encoding/hex"
	"math"
	"math/big"
	"testing"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/iotexproject/go-pkgs/hash"
	"github.com/iotexproject/iotex-address/address"
	"github.com/iotexproject/iotex-proto/golang/iotexapi"
	"github.com/iotexproject/iotex-proto/golang/iotextypes"
	"github.com/mohae/deepcopy"
	"github.com/pkg/errors"
	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/types/known/timestamppb"

	"github.com/iotexproject/iotex-core/action"
	"github.com/iotexproject/iotex-core/action/protocol"
	accountutil "github.com/iotexproject/iotex-core/action/protocol/account/util"
	"github.com/iotexproject/iotex-core/action/protocol/staking"
	"github.com/iotexproject/iotex-core/blockchain/genesis"
	"github.com/iotexproject/iotex-core/config"
	"github.com/iotexproject/iotex-core/pkg/unit"
	"github.com/iotexproject/iotex-core/pkg/util/byteutil"
	"github.com/iotexproject/iotex-core/server/itx"
	"github.com/iotexproject/iotex-core/state"
	"github.com/iotexproject/iotex-core/test/identityset"
)

const (
	// TODO: to be removed
	_const = byte(iota)
	_bucket
	_voterIndex
	_candIndex
	_stakingNameSpace   = "Staking"
	_candidateNameSpace = "Candidate"

	candidate1Name = "candidate1"
	candidate2Name = "candidate2"
	candidate3Name = "candidate3"
)

var (
	selfStake, _     = new(big.Int).SetString("1200000000000000000000000", 10)
	cand1Votes, _    = new(big.Int).SetString("1635067133824581908640994", 10)
	cand1NewVotes, _ = big.NewInt(0).SetString("1542516163985454635820816", 10)
	vote, _          = new(big.Int).SetString("100000000000000000000", 10)
	autoStakeVote, _ = new(big.Int).SetString("103801784016923925869", 10)
	initBalance, _   = new(big.Int).SetString("100000000000000000000000000", 10)

	stakingContractBytecode, _ = hex.DecodeString(`60a060405234801562000010575f80fd5b5060405162002f9a38038062002f9a83398101604081905262000033916200013a565b60405180604001604052806009815260200168109d58dad95d13919560ba1b815250604051806040016040528060038152602001621092d560ea1b815250815f908162000081919062000214565b50600162000090828262000214565b505050620000ad620000a7620000e560201b60201c565b620000e9565b6006805460ff60a01b19169055608091909152600980546001600160a01b0319166001600160a01b03909216919091179055620002e0565b3390565b600680546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b5f80604083850312156200014c575f80fd5b825160208401519092506001600160a01b03811681146200016b575f80fd5b809150509250929050565b634e487b7160e01b5f52604160045260245ffd5b600181811c908216806200019f57607f821691505b602082108103620001be57634e487b7160e01b5f52602260045260245ffd5b50919050565b601f8211156200020f57805f5260205f20601f840160051c81016020851015620001eb5750805b601f840160051c820191505b818110156200020c575f8155600101620001f7565b50505b505050565b81516001600160401b0381111562000230576200023062000176565b62000248816200024184546200018a565b84620001c4565b602080601f8311600181146200027e575f8415620002665750858301515b5f19600386901b1c1916600185901b178555620002d8565b5f85815260208120601f198616915b82811015620002ae578886015182559484019460019091019084016200028d565b5085821015620002cc57878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b608051612c9a620003005f395f818161071f0152611bd80152612c9a5ff3fe60806040526004361061025e575f3560e01c8063715018a61161013f578063b88d4fde116100b3578063ddbcb5fa11610078578063ddbcb5fa1461070e578063e449f34114610741578063e985e9c514610760578063eec7ee73146107a7578063f0b56b5d146107ba578063f2fde38b146107ce575f80fd5b8063b88d4fde1461068a578063b8f4bd7b146106a9578063bbe33ea5146106c8578063c87b56dd146106db578063d0949f99146106fa575f80fd5b80638da5cb5b116101045780638da5cb5b146105e857806393b6ef591461060557806395d89b411461062457806398ca3b7614610638578063a22cb46514610657578063b1724b4614610676575f80fd5b8063715018a6146105865780637acb77571461059a5780638456cb59146105ad57806384ac79b0146105c1578063863e76db146105d4575f80fd5b806338af3eed116101d65780635ceb8b5b1161019b5780635ceb8b5b146104cb5780635d36598f146104ea5780636198e339146105095780636352211e1461052857806370a0823114610547578063711563d414610566575f80fd5b806338af3eed146103f65780633f4ba83a1461041557806342842e0e14610429578063431cd92a146104485780635c975abb146104ad575f80fd5b8063095ea7b311610227578063095ea7b31461033c5780630cdd53f61461035b5780630f5b2ca51461037a5780631338736f1461039957806323b872dd146103b85780632e17de78146103d7575f80fd5b8062f714ce1461026257806301ffc9a71461028357806303459b16146102b757806306fdde03146102e4578063081812fc14610305575b5f80fd5b34801561026d575f80fd5b5061028161027c3660046124c4565b6107ed565b005b34801561028e575f80fd5b506102a261029d366004612507565b61080e565b60405190151581526020015b60405180910390f35b3480156102c2575f80fd5b506102d66102d1366004612522565b61085f565b6040519081526020016102ae565b3480156102ef575f80fd5b506102f8610883565b6040516102ae9190612586565b348015610310575f80fd5b5061032461031f366004612522565b610912565b6040516001600160a01b0390911681526020016102ae565b348015610347575f80fd5b50610281610356366004612598565b610937565b348015610366575f80fd5b506102816103753660046125c2565b610a4b565b348015610385575f80fd5b506102816103943660046124c4565b610b12565b3480156103a4575f80fd5b506102816103b33660046125c2565b610b28565b3480156103c3575f80fd5b506102816103d23660046125e2565b610b43565b3480156103e2575f80fd5b506102816103f1366004612522565b610b74565b348015610401575f80fd5b50600954610324906001600160a01b031681565b348015610420575f80fd5b50610281610b88565b348015610434575f80fd5b506102816104433660046125e2565b610b9a565b348015610453575f80fd5b50610467610462366004612522565b610bb4565b6040516102ae9190815181526020808301519082015260408083015190820152606080830151908201526080918201516001600160a01b03169181019190915260a00190565b3480156104b8575f80fd5b50600654600160a01b900460ff166102a2565b3480156104d6575f80fd5b506102816104e5366004612668565b610c4a565b3480156104f5575f80fd5b506102816105043660046126b0565b610c95565b348015610514575f80fd5b50610281610523366004612522565b610cd0565b348015610533575f80fd5b50610324610542366004612522565b610ce1565b348015610552575f80fd5b506102d66105613660046126ef565b610d40565b61057961057436600461270a565b610dc4565b6040516102ae9190612746565b348015610591575f80fd5b50610281610e91565b6102d66105a83660046124c4565b610ea2565b3480156105b8575f80fd5b50610281610ed1565b6102816105cf3660046125c2565b610ee1565b3480156105df575f80fd5b506102d6600a81565b3480156105f3575f80fd5b506006546001600160a01b0316610324565b348015610610575f80fd5b506102d661061f366004612522565b610f9e565b34801561062f575f80fd5b506102f8610fdc565b348015610643575f80fd5b50610281610652366004612789565b610feb565b348015610662575f80fd5b506102816106713660046127dc565b611027565b348015610681575f80fd5b506102d6611032565b348015610695575f80fd5b506102816106a4366004612851565b61104d565b3480156106b4575f80fd5b506102816106c3366004612789565b61107f565b6102816106d6366004612668565b6110bb565b3480156106e6575f80fd5b506102f86106f5366004612522565b6111ee565b348015610705575f80fd5b506102d65f1981565b348015610719575f80fd5b506102d67f000000000000000000000000000000000000000000000000000000000000000081565b34801561074c575f80fd5b5061028161075b3660046126b0565b61125d565b34801561076b575f80fd5b506102a261077a36600461290e565b6001600160a01b039182165f90815260056020908152604080832093909416825291909152205460ff1690565b6105796107b536600461293a565b611298565b3480156107c5575f80fd5b506102d6611382565b3480156107d9575f80fd5b506102816107e83660046126ef565b61138e565b6107f5611404565b816107ff81611451565b610809838361148b565b505050565b5f6001600160e01b031982166380ac58cd60e01b148061083e57506001600160e01b03198216635b5e139f60e01b145b8061085957506301ffc9a760e01b6001600160e01b03198316145b92915050565b5f6108698261151f565b5f828152600860205260409020600301546108599061157d565b60605f8054610891906129fb565b80601f01602080910402602001604051908101604052809291908181526020018280546108bd906129fb565b80156109085780601f106108df57610100808354040283529160200191610908565b820191905f5260205f20905b8154815290600101906020018083116108eb57829003601f168201915b5050505050905090565b5f61091c8261151f565b505f908152600460205260409020546001600160a01b031690565b5f61094182610ce1565b9050806001600160a01b0316836001600160a01b0316036109b35760405162461bcd60e51b815260206004820152602160248201527f4552433732313a20617070726f76616c20746f2063757272656e74206f776e656044820152603960f91b60648201526084015b60405180910390fd5b336001600160a01b03821614806109cf57506109cf813361077a565b610a415760405162461bcd60e51b815260206004820152603d60248201527f4552433732313a20617070726f76652063616c6c6572206973206e6f7420746f60448201527f6b656e206f776e6572206f7220617070726f76656420666f7220616c6c00000060648201526084016109aa565b61080983836115d0565b81610a5581611451565b5f8381526008602052604090206003810154610a709061163d565b8054831180610a7d575082155b15610a9b576040516359b9300b60e11b815260040160405180910390fd5b82815f015f828254610aad9190612a47565b9091555050600954610ac8906001600160a01b03168461165e565b6009546040518481526001600160a01b039091169085907f1b606d34afacd55873aba0fd274841a10c63e18455f2dffebad2fc60a36b2c839060200160405180910390a350505050565b610b1a611404565b610b2482826116ce565b5050565b610b30611404565b610b3981611775565b610b2482826117c1565b610b4d3382611851565b610b695760405162461bcd60e51b81526004016109aa90612a5a565b6108098383836118cd565b610b7c611404565b610b8581611a3c565b50565b610b90611acd565b610b98611b27565b565b61080983838360405180602001604052805f81525061104d565b610bea6040518060a001604052805f81526020015f81526020015f81526020015f81526020015f6001600160a01b031681525090565b610bf38261151f565b505f90815260086020908152604091829020825160a08101845281548152600182015492810192909252600281015492820192909252600382015460608201526004909101546001600160a01b0316608082015290565b610c52611404565b610c5b81611775565b5f5b82811015610c8f57610c87848483818110610c7a57610c7a612aa7565b90506020020135836117c1565b600101610c5d565b50505050565b610c9d611404565b5f5b8181101561080957610cc8838383818110610cbc57610cbc612aa7565b90506020020135611b7c565b600101610c9f565b610cd8611404565b610b8581611b7c565b5f818152600260205260408120546001600160a01b0316806108595760405162461bcd60e51b8152602060048201526018602482015277115490cdcc8c4e881a5b9d985b1a59081d1bdad95b88125160421b60448201526064016109aa565b5f6001600160a01b038216610da95760405162461bcd60e51b815260206004820152602960248201527f4552433732313a2061646472657373207a65726f206973206e6f7420612076616044820152683634b21037bbb732b960b91b60648201526084016109aa565b506001600160a01b03165f9081526003602052604090205490565b6060610dce611404565b610dd785611bd6565b610de084611775565b34610deb8387612abb565b14610e09576040516359b9300b60e11b815260040160405180910390fd5b8167ffffffffffffffff811115610e2257610e2261280c565b604051908082528060200260200182016040528015610e4b578160200160208202803683370190505b5090505f5b82811015610e8857610e63868686611c17565b828281518110610e7557610e75612aa7565b6020908102919091010152600101610e50565b50949350505050565b610e99611acd565b610b985f611cff565b5f610eab611404565b34610eb581611bd6565b610ebe84611775565b610ec9818585611c17565b949350505050565b610ed9611acd565b610b98611d50565b610ee9611404565b81610ef381611451565b610efc82611775565b5f8381526008602052604090206002810154610f1790611d93565b8060010154831015610f3c5760405163257a8d4b60e11b815260040160405180910390fd5b34815f015f828254610f4e9190612ad2565b9091555050600181018390558054604080519182526020820185905285917fd29e04160a74f0dbab5e7b82ef0392d86d11ac2939e5883eb3353be4cfedb83e91015b60405180910390a250505050565b5f610fa88261151f565b5f8281526008602052604090206003810154610fc39061163d565b610fd581600201548260010154611db4565b9392505050565b606060018054610891906129fb565b610ff3611404565b5f5b82811015610c8f5761101f84848381811061101257611012612aa7565b90506020020135836116ce565b600101610ff5565b610b24338383611deb565b61103f600a61016d612abb565b61104a906003612abb565b81565b6110573383611851565b6110735760405162461bcd60e51b81526004016109aa90612a5a565b610c8f84848484611eb8565b611087611404565b5f5b82811015610c8f576110b38484838181106110a6576110a6612aa7565b905060200201358361148b565b600101611089565b6110c3611404565b600182116110e457604051637e878a5f60e11b815260040160405180910390fd5b6110ed81611775565b345f80845b80156111e5575f190186868281811061110d5761110d612aa7565b90506020020135925061111f83611451565b5f838152600860205260409020600381015490925061113d9061163d565b61114f82600201548360010154611db4565b85101561116f5760405163257a8d4b60e11b815260040160405180910390fd5b815461117b9085612ad2565b935080156111915761118c83611eeb565b6110f2565b5f196002830155838255600182018590556040517fb3f4c8ca702dbbd32d9a25ce17b1942a5060284d9d69fc4fcac8fb0397891b12906111d8908990899088908a90612ae5565b60405180910390a16110f2565b50505050505050565b60606111f98261151f565b5f61120e60408051602081019091525f815290565b90505f81511161122c5760405180602001604052805f815250610fd5565b8061123684611f8a565b604051602001611247929190612b29565b6040516020818303038152906040529392505050565b611265611404565b5f5b818110156108095761129083838381811061128457611284612aa7565b90506020020135611a3c565b600101611267565b60606112a2611404565b6112ab84611bd6565b6112b483611775565b348251856112c29190612abb565b146112e0576040516359b9300b60e11b815260040160405180910390fd5b815167ffffffffffffffff8111156112fa576112fa61280c565b604051908082528060200260200182016040528015611323578160200160208202803683370190505b5090505f5b825181101561137a57611355858585848151811061134857611348612aa7565b6020026020010151611c17565b82828151811061136757611367612aa7565b6020908102919091010152600101611328565b509392505050565b61104a600a6003612abb565b611396611acd565b6001600160a01b0381166113fb5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084016109aa565b610b8581611cff565b600654600160a01b900460ff1615610b985760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016109aa565b61145a81610ce1565b6001600160a01b0316336001600160a01b031614610b8557604051630da4973960e31b815260040160405180910390fd5b8161149581611451565b5f83815260086020526040902060038101546114b09061157d565b156114ce57604051634e395b8560e01b815260040160405180910390fd5b6114d784611eeb565b6114e483825f015461165e565b6040516001600160a01b0384169085907fd964a27d45f595739c13d8b1160b57491050cacf3a2e5602207277d6228f64ee905f90a350505050565b5f818152600260205260409020546001600160a01b0316610b855760405162461bcd60e51b8152602060048201526018602482015277115490cdcc8c4e881a5b9d985b1a59081d1bdad95b88125160421b60448201526064016109aa565b5f5f19820361159f57604051636263fd5f60e11b815260040160405180910390fd5b5f6115ac600a6003612abb565b6115b69084612ad2565b90504381116115c757505f92915050565b43900392915050565b5f81815260046020526040902080546001600160a01b0319166001600160a01b038416908117909155819061160482610ce1565b6001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b5f198114610b85576040516343febe2b60e01b815260040160405180910390fd5b5f826001600160a01b0316826040515f6040518083038185875af1925050503d805f81146116a7576040519150601f19603f3d011682016040523d82523d5f602084013e6116ac565b606091505b505090508061080957604051639a7058e160e01b815260040160405180910390fd5b816116d881611451565b5f83815260086020526040902060038101546116f39061163d565b60048101546001600160a01b0380851691160361172357604051637e878a5f60e11b815260040160405180910390fd5b6004810180546001600160a01b0319166001600160a01b03851690811790915560405190815284907f6f08c7e76d830d5f3d0a18fd27f4d8c0049b24a8689ddb39625e0864d894a9c190602001610f90565b611780600a82612b57565b1515806117a35750611795600a61016d612abb565b6117a0906003612abb565b81115b15610b855760405163257a8d4b60e11b815260040160405180910390fd5b816117cb81611451565b5f83815260086020526040902060038101546117e69061163d565b6117f881600201548260010154611db4565b8310156118185760405163257a8d4b60e11b815260040160405180910390fd5b5f19600282015560405183815284907f907fece23ce39fbcbceb71e515043fe29408353fbb393b25b35eb8a70a4bad0b90602001610f90565b5f8061185c83610ce1565b9050806001600160a01b0316846001600160a01b031614806118a257506001600160a01b038082165f9081526005602090815260408083209388168352929052205460ff165b80610ec95750836001600160a01b03166118bb84610912565b6001600160a01b031614949350505050565b826001600160a01b03166118e082610ce1565b6001600160a01b0316146119065760405162461bcd60e51b81526004016109aa90612b76565b6001600160a01b0382166119685760405162461bcd60e51b8152602060048201526024808201527f4552433732313a207472616e7366657220746f20746865207a65726f206164646044820152637265737360e01b60648201526084016109aa565b611975838383600161201a565b826001600160a01b031661198882610ce1565b6001600160a01b0316146119ae5760405162461bcd60e51b81526004016109aa90612b76565b5f81815260046020908152604080832080546001600160a01b03199081169091556001600160a01b038781168086526003855283862080545f1901905590871680865283862080546001019055868652600290945282852080549092168417909155905184937fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b80611a4681611451565b5f8281526008602052604090206003810154611a619061163d565b611a7381600201548260010154611db4565b15611a9157604051634e395b8560e01b815260040160405180910390fd5b4360028201819055600382015560405183907f11725367022c3ff288940f4b5473aa61c2da6a24af7363a1128ee2401e8983b2905f90a2505050565b6006546001600160a01b03163314610b985760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016109aa565b611b2f612026565b6006805460ff60a01b191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b80611b8681611451565b5f8281526008602052604090206002810154611ba190611d93565b43600282015560405183907ff27b6ce5b2f5e68ddb2fd95a8a909d4ecf1daaac270935fff052feacb24f1842905f90a2505050565b7f0000000000000000000000000000000000000000000000000000000000000000811015610b85576040516359b9300b60e11b815260040160405180910390fd5b5f80611c2560075460010190565b60078190556040805160a08101825287815260208082018881525f19838501818152606085019182526001600160a01b038a8116608087019081525f8981526008909652969094209451855591516001850155905160028401555160038301559151600490910180546001600160a01b031916919092161790559050611cab3382612076565b604080516001600160a01b03851681526020810187905290810185905281907f17700ceb1658b18206f427c1578048e87504106b14ec69e9b4586d9a95174a329060600160405180910390a2949350505050565b600680546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b611d58611404565b6006805460ff60a01b1916600160a01b1790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258611b5f3390565b5f198114610b855760405163da808c7560e01b815260040160405180910390fd5b5f5f198303611dc4575080610859565b5f611dcf8385612ad2565b9050438111611de1575f915050610859565b4390039392505050565b816001600160a01b0316836001600160a01b031603611e4c5760405162461bcd60e51b815260206004820152601960248201527f4552433732313a20617070726f766520746f2063616c6c65720000000000000060448201526064016109aa565b6001600160a01b038381165f81815260056020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b611ec38484846118cd565b611ecf8484848461208f565b610c8f5760405162461bcd60e51b81526004016109aa90612bbb565b5f611ef582610ce1565b9050611f04815f84600161201a565b611f0d82610ce1565b5f83815260046020908152604080832080546001600160a01b03199081169091556001600160a01b0385168085526003845282852080545f190190558785526002909352818420805490911690555192935084927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908390a45050565b60605f611f968361218c565b60010190505f8167ffffffffffffffff811115611fb557611fb561280c565b6040519080825280601f01601f191660200182016040528015611fdf576020820181803683370190505b5090508181016020015b5f19016f181899199a1a9b1b9c1cb0b131b232b360811b600a86061a8153600a8504945084611fe957509392505050565b610c8f84848484612263565b600654600160a01b900460ff16610b985760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b60448201526064016109aa565b610b24828260405180602001604052805f8152506122e9565b5f6001600160a01b0384163b1561218157604051630a85bd0160e11b81526001600160a01b0385169063150b7a02906120d2903390899088908890600401612c0d565b6020604051808303815f875af192505050801561210c575060408051601f3d908101601f1916820190925261210991810190612c49565b60015b612167573d808015612139576040519150601f19603f3d011682016040523d82523d5f602084013e61213e565b606091505b5080515f0361215f5760405162461bcd60e51b81526004016109aa90612bbb565b805181602001fd5b6001600160e01b031916630a85bd0160e11b149050610ec9565b506001949350505050565b5f8072184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b83106121ca5772184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b830492506040015b6d04ee2d6d415b85acef810000000083106121f6576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc10000831061221457662386f26fc10000830492506010015b6305f5e100831061222c576305f5e100830492506008015b612710831061224057612710830492506004015b60648310612252576064830492506002015b600a83106108595760010192915050565b6001811115610c8f576001600160a01b038416156122a8576001600160a01b0384165f90815260036020526040812080548392906122a2908490612a47565b90915550505b6001600160a01b03831615610c8f576001600160a01b0383165f90815260036020526040812080548392906122de908490612ad2565b909155505050505050565b6122f3838361231b565b6122ff5f84848461208f565b6108095760405162461bcd60e51b81526004016109aa90612bbb565b6001600160a01b0382166123715760405162461bcd60e51b815260206004820181905260248201527f4552433732313a206d696e7420746f20746865207a65726f206164647265737360448201526064016109aa565b5f818152600260205260409020546001600160a01b0316156123d55760405162461bcd60e51b815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e7465640000000060448201526064016109aa565b6123e25f8383600161201a565b5f818152600260205260409020546001600160a01b0316156124465760405162461bcd60e51b815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e7465640000000060448201526064016109aa565b6001600160a01b0382165f81815260036020908152604080832080546001019055848352600290915280822080546001600160a01b0319168417905551839291907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a45050565b6001600160a01b0381168114610b85575f80fd5b5f80604083850312156124d5575f80fd5b8235915060208301356124e7816124b0565b809150509250929050565b6001600160e01b031981168114610b85575f80fd5b5f60208284031215612517575f80fd5b8135610fd5816124f2565b5f60208284031215612532575f80fd5b5035919050565b5f5b8381101561255357818101518382015260200161253b565b50505f910152565b5f8151808452612572816020860160208601612539565b601f01601f19169290920160200192915050565b602081525f610fd5602083018461255b565b5f80604083850312156125a9575f80fd5b82356125b4816124b0565b946020939093013593505050565b5f80604083850312156125d3575f80fd5b50508035926020909101359150565b5f805f606084860312156125f4575f80fd5b83356125ff816124b0565b9250602084013561260f816124b0565b929592945050506040919091013590565b5f8083601f840112612630575f80fd5b50813567ffffffffffffffff811115612647575f80fd5b6020830191508360208260051b8501011115612661575f80fd5b9250929050565b5f805f6040848603121561267a575f80fd5b833567ffffffffffffffff811115612690575f80fd5b61269c86828701612620565b909790965060209590950135949350505050565b5f80602083850312156126c1575f80fd5b823567ffffffffffffffff8111156126d7575f80fd5b6126e385828601612620565b90969095509350505050565b5f602082840312156126ff575f80fd5b8135610fd5816124b0565b5f805f806080858703121561271d575f80fd5b84359350602085013592506040850135612736816124b0565b9396929550929360600135925050565b602080825282518282018190525f9190848201906040850190845b8181101561277d57835183529284019291840191600101612761565b50909695505050505050565b5f805f6040848603121561279b575f80fd5b833567ffffffffffffffff8111156127b1575f80fd5b6127bd86828701612620565b90945092505060208401356127d1816124b0565b809150509250925092565b5f80604083850312156127ed575f80fd5b82356127f8816124b0565b9150602083013580151581146124e7575f80fd5b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff811182821017156128495761284961280c565b604052919050565b5f805f8060808587031215612864575f80fd5b843561286f816124b0565b9350602085810135612880816124b0565b935060408601359250606086013567ffffffffffffffff808211156128a3575f80fd5b818801915088601f8301126128b6575f80fd5b8135818111156128c8576128c861280c565b6128da601f8201601f19168501612820565b915080825289848285010111156128ef575f80fd5b80848401858401375f8482840101525080935050505092959194509250565b5f806040838503121561291f575f80fd5b823561292a816124b0565b915060208301356124e7816124b0565b5f805f6060848603121561294c575f80fd5b833592506020808501359250604085013567ffffffffffffffff80821115612972575f80fd5b818701915087601f830112612985575f80fd5b8135818111156129975761299761280c565b8060051b91506129a8848301612820565b818152918301840191848101908a8411156129c1575f80fd5b938501935b838510156129eb57843592506129db836124b0565b82825293850193908501906129c6565b8096505050505050509250925092565b600181811c90821680612a0f57607f821691505b602082108103612a2d57634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52601160045260245ffd5b8181038181111561085957610859612a33565b6020808252602d908201527f4552433732313a2063616c6c6572206973206e6f7420746f6b656e206f776e6560408201526c1c881bdc88185c1c1c9bdd9959609a1b606082015260800190565b634e487b7160e01b5f52603260045260245ffd5b808202811582820484141761085957610859612a33565b8082018082111561085957610859612a33565b606080825281018490525f6001600160fb1b03851115612b03575f80fd5b8460051b8087608085013760208301949094525060408101919091520160800192915050565b5f8351612b3a818460208801612539565b835190830190612b4e818360208801612539565b01949350505050565b5f82612b7157634e487b7160e01b5f52601260045260245ffd5b500690565b60208082526025908201527f4552433732313a207472616e736665722066726f6d20696e636f72726563742060408201526437bbb732b960d91b606082015260800190565b60208082526032908201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560408201527131b2b4bb32b91034b6b83632b6b2b73a32b960711b606082015260800190565b6001600160a01b03858116825284166020820152604081018390526080606082018190525f90612c3f9083018461255b565b9695505050505050565b5f60208284031215612c59575f80fd5b8151610fd5816124f256fea2646970667358221220205b2909c5a9d941c62e75ad22db4e210223e35d30466fe9ac16d3f20eeb406b64736f6c63430008160033`)
)

var (
	gasPrice = big.NewInt(0)
	gasLimit = uint64(10000000)
)

func TestNativeStaking(t *testing.T) {
	require := require.New(t)

	testInitCands := []genesis.BootstrapCandidate{
		{
			OwnerAddress:      identityset.Address(22).String(),
			OperatorAddress:   identityset.Address(23).String(),
			RewardAddress:     identityset.Address(23).String(),
			Name:              "test1",
			SelfStakingTokens: selfStake.String(),
		},
		{
			OwnerAddress:      identityset.Address(24).String(),
			OperatorAddress:   identityset.Address(25).String(),
			RewardAddress:     identityset.Address(25).String(),
			Name:              "test2",
			SelfStakingTokens: selfStake.String(),
		},
	}

	testNativeStaking := func(cfg config.Config, t *testing.T) {
		ctx := context.Background()

		// Create a new blockchain
		svr, err := itx.NewServer(cfg)
		require.NoError(err)
		require.NoError(svr.Start(ctx))
		defer func() {
			require.NoError(svr.Stop(ctx))
		}()

		chainID := cfg.Chain.ID
		bc := svr.ChainService(chainID).Blockchain()
		sf := svr.ChainService(chainID).StateFactory()
		ap := svr.ChainService(chainID).ActionPool()
		require.NotNil(bc)
		prtcl, ok := svr.ChainService(chainID).Registry().Find("staking")
		require.True(ok)
		stkPrtcl := prtcl.(*staking.Protocol)

		require.True(cfg.Genesis.IsFbkMigration(1))

		// Create two candidates
		cand1Addr := identityset.Address(0)
		cand1PriKey := identityset.PrivateKey(0)

		cand2Addr := identityset.Address(1)
		cand2PriKey := identityset.PrivateKey(1)

		// create non-stake candidate
		cand3Addr := identityset.Address(4)
		cand3PriKey := identityset.PrivateKey(4)

		fixedTime := time.Unix(cfg.Genesis.Timestamp, 0)
		addOneTx := func(tx *action.SealedEnvelope, err error) (*action.SealedEnvelope, *action.Receipt, error) {
			if err != nil {
				return tx, nil, err
			}
			if err := ap.Add(ctx, tx); err != nil {
				return tx, nil, err
			}
			blk, err := createAndCommitBlock(bc, ap, fixedTime)
			if err != nil {
				return tx, nil, err
			}
			h, err := tx.Hash()
			if err != nil {
				return tx, nil, err
			}
			for _, r := range blk.Receipts {
				if r.ActionHash == h {
					return tx, r, nil
				}
			}
			return tx, nil, errors.Errorf("failed to find receipt for %x", h)
		}

		register1, r1, err := addOneTx(action.SignedCandidateRegister(1, candidate1Name, cand1Addr.String(), cand1Addr.String(),
			cand1Addr.String(), selfStake.String(), 91, true, nil, gasLimit, gasPrice, cand1PriKey, action.WithChainID(chainID)))
		require.NoError(err)
		register2, _, err := addOneTx(action.SignedCandidateRegister(1, candidate2Name, cand2Addr.String(), cand2Addr.String(),
			cand2Addr.String(), selfStake.String(), 1, false, nil, gasLimit, gasPrice, cand2PriKey, action.WithChainID(chainID)))
		require.NoError(err)
		// check candidate state
		require.NoError(checkCandidateState(sf, candidate1Name, cand1Addr.String(), selfStake, cand1Votes, cand1Addr))
		require.NoError(checkCandidateState(sf, candidate2Name, cand2Addr.String(), selfStake, selfStake, cand2Addr))

		// check candidate account state
		require.NoError(checkAccountState(cfg, sf, register1, true, initBalance, cand1Addr))
		require.NoError(checkAccountState(cfg, sf, register2, true, initBalance, cand2Addr))

		// get self-stake index from receipts
		require.EqualValues(iotextypes.ReceiptStatus_Success, r1.Status)
		logs := r1.Logs()
		require.Equal(3, len(logs[0].Topics))
		require.Equal(hash.BytesToHash256([]byte(staking.HandleCandidateRegister)), logs[0].Topics[0])
		selfstakeIndex1 := byteutil.BytesToUint64BigEndian(logs[0].Topics[1][24:])
		require.Equal(hash.BytesToHash256(cand1Addr.Bytes()), logs[0].Topics[2])

		// create two stakes from two voters
		voter1Addr := identityset.Address(2)
		voter1PriKey := identityset.PrivateKey(2)

		voter2Addr := identityset.Address(3)
		voter2PriKey := identityset.PrivateKey(3)

		cs1, r1, err := addOneTx(action.SignedCreateStake(1, candidate1Name, vote.String(), 1, false,
			nil, gasLimit, gasPrice, voter1PriKey, action.WithChainID(chainID)))
		require.NoError(err)
		cs2, r2, err := addOneTx(action.SignedCreateStake(1, candidate1Name, vote.String(), 1, false,
			nil, gasLimit, gasPrice, voter2PriKey, action.WithChainID(chainID)))
		require.NoError(err)

		// check candidate state
		expectedVotes := big.NewInt(0).Add(cand1Votes, big.NewInt(0).Mul(vote, big.NewInt(2)))
		require.NoError(checkCandidateState(sf, candidate1Name, cand1Addr.String(), selfStake, expectedVotes, cand1Addr))

		// check voter account state
		require.NoError(checkAccountState(cfg, sf, cs1, false, initBalance, voter1Addr))
		require.NoError(checkAccountState(cfg, sf, cs2, false, initBalance, voter2Addr))

		// get bucket index from receipts
		require.EqualValues(iotextypes.ReceiptStatus_Success, r1.Status)
		logs = r1.Logs()
		require.Equal(3, len(logs[0].Topics))
		require.Equal(hash.BytesToHash256([]byte(staking.HandleCreateStake)), logs[0].Topics[0])
		require.Equal(hash.BytesToHash256(cand1Addr.Bytes()), logs[0].Topics[2])
		voter1BucketIndex := byteutil.BytesToUint64BigEndian(logs[0].Topics[1][24:])

		require.EqualValues(iotextypes.ReceiptStatus_Success, r2.Status)
		logs = r2.Logs()
		require.Equal(3, len(logs[0].Topics))
		require.Equal(hash.BytesToHash256([]byte(staking.HandleCreateStake)), logs[0].Topics[0])
		require.Equal(hash.BytesToHash256(cand1Addr.Bytes()), logs[0].Topics[2])
		voter2BucketIndex := byteutil.BytesToUint64BigEndian(logs[0].Topics[1][24:])

		// change candidate
		_, rc, err := addOneTx(action.SignedChangeCandidate(2, candidate2Name, voter2BucketIndex, nil,
			gasLimit, gasPrice, voter2PriKey))
		require.NoError(err)

		require.EqualValues(iotextypes.ReceiptStatus_Success, rc.Status)
		logs = rc.Logs()
		require.Equal(4, len(logs[0].Topics))
		require.Equal(hash.BytesToHash256([]byte(staking.HandleChangeCandidate)), logs[0].Topics[0])
		require.Equal(voter2BucketIndex, byteutil.BytesToUint64BigEndian(logs[0].Topics[1][24:]))
		require.Equal(hash.BytesToHash256(cand1Addr.Bytes()), logs[0].Topics[2])
		require.Equal(hash.BytesToHash256(cand2Addr.Bytes()), logs[0].Topics[3])

		// check candidate state
		expectedVotes = big.NewInt(0).Add(cand1Votes, vote)
		require.NoError(checkCandidateState(sf, candidate1Name, cand1Addr.String(), selfStake, expectedVotes, cand1Addr))
		expectedVotes = big.NewInt(0).Add(selfStake, vote)
		require.NoError(checkCandidateState(sf, candidate2Name, cand2Addr.String(), selfStake, expectedVotes, cand2Addr))

		// transfer stake
		_, rt, err := addOneTx(action.SignedTransferStake(2, voter2Addr.String(), voter1BucketIndex, nil, gasLimit, gasPrice, voter1PriKey))
		require.NoError(err)

		require.EqualValues(iotextypes.ReceiptStatus_Success, rt.Status)
		logs = rt.Logs()
		require.Equal(4, len(logs[0].Topics))
		require.Equal(hash.BytesToHash256([]byte(staking.HandleTransferStake)), logs[0].Topics[0])
		require.Equal(voter1BucketIndex, byteutil.BytesToUint64BigEndian(logs[0].Topics[1][24:]))
		require.Equal(hash.BytesToHash256(voter2Addr.Bytes()), logs[0].Topics[2])
		require.Equal(hash.BytesToHash256(cand1Addr.Bytes()), logs[0].Topics[3])

		// check buckets
		var bis staking.BucketIndices
		_, err = sf.State(&bis, protocol.NamespaceOption(_stakingNameSpace),
			protocol.KeyOption(staking.AddrKeyWithPrefix(voter1Addr, _voterIndex)))
		require.Error(err)
		require.Equal(state.ErrStateNotExist, errors.Cause(err))

		_, err = sf.State(&bis, protocol.NamespaceOption(_stakingNameSpace),
			protocol.KeyOption(staking.AddrKeyWithPrefix(voter2Addr, _voterIndex)))
		require.NoError(err)
		require.Equal(2, len(bis))
		require.Equal(voter2BucketIndex, bis[0])
		require.Equal(voter1BucketIndex, bis[1])

		// deposit to stake
		ds, rd, err := addOneTx(action.SignedDepositToStake(3, voter2BucketIndex, vote.String(), nil, gasLimit, gasPrice, voter2PriKey))
		require.NoError(err)

		require.EqualValues(iotextypes.ReceiptStatus_ErrInvalidBucketType, rd.Status)
		logs = rd.Logs()
		require.Equal(4, len(logs[0].Topics))
		require.Equal(hash.BytesToHash256([]byte(staking.HandleDepositToStake)), logs[0].Topics[0])
		require.Equal(voter2BucketIndex, byteutil.BytesToUint64BigEndian(logs[0].Topics[1][24:]))
		require.Equal(hash.BytesToHash256(voter2Addr.Bytes()), logs[0].Topics[2])
		require.Equal(hash.BytesToHash256(cand2Addr.Bytes()), logs[0].Topics[3])

		// restake
		_, rr, err := addOneTx(action.SignedRestake(4, voter2BucketIndex, 1, true, nil,
			gasLimit, gasPrice, voter2PriKey))
		require.NoError(err)

		require.EqualValues(iotextypes.ReceiptStatus_Success, rr.Status)
		logs = rr.Logs()
		require.Equal(3, len(logs[0].Topics))
		require.Equal(hash.BytesToHash256([]byte(staking.HandleRestake)), logs[0].Topics[0])
		require.Equal(voter2BucketIndex, byteutil.BytesToUint64BigEndian(logs[0].Topics[1][24:]))
		require.Equal(hash.BytesToHash256(cand2Addr.Bytes()), logs[0].Topics[2])

		// check candidate state
		expectedVotes = big.NewInt(0).Add(selfStake, autoStakeVote)
		require.NoError(checkCandidateState(sf, candidate2Name, cand2Addr.String(), selfStake, expectedVotes, cand2Addr))

		// deposit to stake again
		ds, rd, err = addOneTx(action.SignedDepositToStake(5, voter2BucketIndex, vote.String(), nil, gasLimit, gasPrice, voter2PriKey))
		require.NoError(err)

		// check voter account state
		require.NoError(checkAccountState(cfg, sf, ds, false, big.NewInt(0).Sub(initBalance, vote), voter2Addr))

		// unstake voter stake
		_, ru, err := addOneTx(action.SignedReclaimStake(false, 6, voter1BucketIndex, nil, gasLimit, gasPrice, voter2PriKey))
		require.NoError(err)

		require.Equal(uint64(iotextypes.ReceiptStatus_ErrUnstakeBeforeMaturity), ru.Status)
		logs = ru.Logs()
		require.Equal(3, len(logs[0].Topics))
		require.Equal(hash.BytesToHash256([]byte(staking.HandleUnstake)), logs[0].Topics[0])
		require.Equal(voter1BucketIndex, byteutil.BytesToUint64BigEndian(logs[0].Topics[1][24:]))
		require.Equal(hash.BytesToHash256(cand1Addr.Bytes()), logs[0].Topics[2])

		unstakeTime := fixedTime.Add(time.Duration(1) * 24 * time.Hour)
		addOneTx = func(tx *action.SealedEnvelope, err error) (*action.SealedEnvelope, *action.Receipt, error) {
			if err != nil {
				return tx, nil, err
			}
			if err := ap.Add(ctx, tx); err != nil {
				return tx, nil, err
			}
			blk, err := createAndCommitBlock(bc, ap, unstakeTime)
			if err != nil {
				return tx, nil, err
			}
			h, err := tx.Hash()
			if err != nil {
				return tx, nil, err
			}
			for _, r := range blk.Receipts {
				if r.ActionHash == h {
					return tx, r, nil
				}
			}
			return tx, nil, errors.Errorf("failed to find receipt for %x", h)
		}

		// unstake with correct timestamp
		_, ru, err = addOneTx(action.SignedReclaimStake(false, 7, voter1BucketIndex, nil, gasLimit, gasPrice, voter2PriKey))
		require.NoError(err)

		require.Equal(uint64(iotextypes.ReceiptStatus_Success), ru.Status)
		logs = ru.Logs()
		require.Equal(3, len(logs[0].Topics))
		require.Equal(hash.BytesToHash256([]byte(staking.HandleUnstake)), logs[0].Topics[0])
		require.Equal(voter1BucketIndex, byteutil.BytesToUint64BigEndian(logs[0].Topics[1][24:]))
		require.Equal(hash.BytesToHash256(cand1Addr.Bytes()), logs[0].Topics[2])

		// check candidate state
		require.NoError(checkCandidateState(sf, candidate1Name, cand1Addr.String(), selfStake, cand1Votes, cand1Addr))

		// unstake self stake
		_, ru, err = addOneTx(action.SignedReclaimStake(false, 2, selfstakeIndex1, nil, gasLimit, gasPrice, cand1PriKey))
		require.NoError(err)

		require.EqualValues(iotextypes.ReceiptStatus_ErrInvalidBucketType, ru.Status)
		logs = ru.Logs()
		require.Equal(3, len(logs[0].Topics))
		require.Equal(hash.BytesToHash256([]byte(staking.HandleUnstake)), logs[0].Topics[0])
		require.Equal(selfstakeIndex1, byteutil.BytesToUint64BigEndian(logs[0].Topics[1][24:]))
		require.Equal(hash.BytesToHash256(cand1Addr.Bytes()), logs[0].Topics[2])

		// check candidate state
		require.NoError(checkCandidateState(sf, candidate1Name, cand1Addr.String(), selfStake, cand1Votes, cand1Addr))

		// withdraw stake
		ws, rw, err := addOneTx(action.SignedReclaimStake(true, 3, selfstakeIndex1, nil, gasLimit, gasPrice, cand1PriKey))
		require.NoError(err)

		require.EqualValues(iotextypes.ReceiptStatus_ErrWithdrawBeforeUnstake, rw.Status)
		logs = rw.Logs()
		require.Equal(3, len(logs[0].Topics))
		require.Equal(hash.BytesToHash256([]byte(staking.HandleWithdrawStake)), logs[0].Topics[0])
		require.Equal(selfstakeIndex1, byteutil.BytesToUint64BigEndian(logs[0].Topics[1][24:]))
		require.Equal(hash.BytesToHash256(cand1Addr.Bytes()), logs[0].Topics[2])

		// withdraw	with correct timestamp
		unstakeTime = unstakeTime.Add(cfg.Genesis.WithdrawWaitingPeriod)
		ws, rw, err = addOneTx(action.SignedReclaimStake(true, 4, selfstakeIndex1, nil, gasLimit, gasPrice, cand1PriKey))
		require.NoError(err)

		require.EqualValues(iotextypes.ReceiptStatus_ErrWithdrawBeforeUnstake, rw.Status)
		logs = rw.Logs()
		require.Equal(3, len(logs[0].Topics))
		require.Equal(hash.BytesToHash256([]byte(staking.HandleWithdrawStake)), logs[0].Topics[0])
		require.Equal(selfstakeIndex1, byteutil.BytesToUint64BigEndian(logs[0].Topics[1][24:]))
		require.Equal(hash.BytesToHash256(cand1Addr.Bytes()), logs[0].Topics[2])

		// check buckets
		_, err = sf.State(&bis, protocol.NamespaceOption(_stakingNameSpace),
			protocol.KeyOption(staking.AddrKeyWithPrefix(cand1Addr, _voterIndex)))
		require.NoError(err)
		require.Equal(1, len(bis))

		_, err = sf.State(&bis, protocol.NamespaceOption(_stakingNameSpace),
			protocol.KeyOption(staking.AddrKeyWithPrefix(cand1Addr, _candIndex)))
		require.NoError(err)
		require.Equal(2, len(bis))

		// check candidate account state
		require.NoError(checkAccountState(cfg, sf, ws, true, big.NewInt(0).Sub(initBalance, selfStake), cand1Addr))

		// register without stake
		register3, r3, err := addOneTx(action.SignedCandidateRegister(1, candidate3Name, cand3Addr.String(), cand3Addr.String(),
			cand3Addr.String(), "0", 1, false, nil, gasLimit, gasPrice, cand3PriKey, action.WithChainID(chainID)))
		require.NoError(err)
		require.EqualValues(iotextypes.ReceiptStatus_Success, r3.Status)
		require.NoError(checkCandidateState(sf, candidate3Name, cand3Addr.String(), big.NewInt(0), big.NewInt(0), cand3Addr))
		require.NoError(checkAccountState(cfg, sf, register3, true, initBalance, cand3Addr))

		ctx, err = bc.Context(ctx)
		require.NoError(err)
		ctx = protocol.WithBlockCtx(ctx, protocol.BlockCtx{
			BlockHeight: bc.TipHeight() + 1,
		})
		ctx = protocol.WithFeatureCtx(ctx)
		cands, err := stkPrtcl.ActiveCandidates(ctx, sf, 0)
		require.NoError(err)
		require.Equal(4, len(cands))
		for _, cand := range cands {
			t.Logf("\ncandidate=%+v, %+v\n", string(cand.CanName), cand.Votes.String())
		}
		// stake bucket
		_, cr3, err := addOneTx(action.SignedCreateStake(3, candidate3Name, selfStake.String(), 1, false,
			nil, gasLimit, gasPrice, voter1PriKey, action.WithChainID(chainID)))
		require.NoError(err)
		require.EqualValues(iotextypes.ReceiptStatus_Success, cr3.Status)
		logs = cr3.Logs()
		require.Equal(3, len(logs[0].Topics))
		require.Equal(hash.BytesToHash256([]byte(staking.HandleCreateStake)), logs[0].Topics[0])
		endorseBucketIndex := byteutil.BytesToUint64BigEndian(logs[0].Topics[1][24:])
		t.Logf("endorseBucketIndex=%+v", endorseBucketIndex)
		// endorse bucket
		_, esr, err := addOneTx(action.SignedCandidateEndorsementLegacy(4, endorseBucketIndex, true, gasLimit, gasPrice, voter1PriKey, action.WithChainID(chainID)))
		require.NoError(err)
		require.NoError(err)
		require.EqualValues(iotextypes.ReceiptStatus_Success, esr.Status)
		// candidate self stake
		_, cssr, err := addOneTx(action.SignedCandidateActivate(2, endorseBucketIndex, gasLimit, gasPrice, cand3PriKey, action.WithChainID(chainID)))
		require.NoError(err)
		require.EqualValues(iotextypes.ReceiptStatus_Success, cssr.Status)
		ctx = protocol.WithBlockCtx(ctx, protocol.BlockCtx{
			BlockHeight: bc.TipHeight() + 1,
		})
		ctx = protocol.WithFeatureCtx(ctx)
		cands, err = stkPrtcl.ActiveCandidates(ctx, sf, 0)
		require.NoError(err)
		require.Equal(5, len(cands))
		for _, cand := range cands {
			t.Logf("\ncandidate=%+v, %+v\n", string(cand.CanName), cand.Votes.String())
		}
		// unendorse bucket
		_, esr, err = addOneTx(action.SignedCandidateEndorsementLegacy(5, endorseBucketIndex, false, gasLimit, gasPrice, voter1PriKey, action.WithChainID(chainID)))
		require.NoError(err)
		require.EqualValues(iotextypes.ReceiptStatus_Success, esr.Status)
		ctx = protocol.WithBlockCtx(ctx, protocol.BlockCtx{
			BlockHeight: bc.TipHeight() + 1,
		})
		cands, err = stkPrtcl.ActiveCandidates(ctx, sf, 0)
		require.NoError(err)
		require.Equal(5, len(cands))
		t.Run("endorsement is withdrawing, candidate can also be chosen as delegate", func(t *testing.T) {
			ctx, err = bc.Context(ctx)
			require.NoError(err)
			ctx = protocol.WithBlockCtx(ctx, protocol.BlockCtx{
				BlockHeight: 2,
			})
			ctx = protocol.WithFeatureCtx(ctx)
			cands, err = stkPrtcl.ActiveCandidates(ctx, sf, 0)
			require.NoError(err)
			require.Equal(5, len(cands))
		})
		t.Run("endorsement is expired, candidate can not be chosen as delegate any more", func(t *testing.T) {
			ctx, err = bc.Context(ctx)
			require.NoError(err)
			jumpBlocks(bc, int(cfg.Genesis.EndorsementWithdrawWaitingBlocks), require)
			ctx = protocol.WithBlockCtx(ctx, protocol.BlockCtx{
				BlockHeight: 2,
			})
			ctx = protocol.WithFeatureCtx(ctx)
			cands, err = stkPrtcl.ActiveCandidates(ctx, sf, 0)
			require.NoError(err)
			require.Equal(4, len(cands))
		})
		t.Run("candidate transfer ownership to self", func(t *testing.T) {
			_, ccto, err := addOneTx(action.SignedCandidateTransferOwnership(5, cand1Addr.String(), nil, gasLimit, gasPrice, cand1PriKey, action.WithChainID(chainID)))
			require.NoError(err)
			require.EqualValues(iotextypes.ReceiptStatus_ErrUnauthorizedOperator, ccto.Status)
			require.NoError(checkCandidateState(sf, candidate1Name, cand1Addr.String(), selfStake, cand1Votes, cand1Addr))
		})

		t.Run("candidate transfer ownership to a normal new address", func(t *testing.T) {
			newOwner1 := identityset.Address(33)
			_, ccto, err := addOneTx(action.SignedCandidateTransferOwnership(6, newOwner1.String(), nil, gasLimit, gasPrice, cand1PriKey, action.WithChainID(chainID)))
			require.NoError(err)
			require.EqualValues(iotextypes.ReceiptStatus_Success, ccto.Status)
			require.NoError(checkCandidateState(sf, candidate1Name, newOwner1.String(), big.NewInt(0), cand1NewVotes, cand1Addr))
		})
		t.Run("candidate transfer ownership to a exist candidate", func(t *testing.T) {
			_, ccto, err := addOneTx(action.SignedCandidateTransferOwnership(7, cand2Addr.String(), nil, gasLimit, gasPrice, cand1PriKey, action.WithChainID(chainID)))
			require.NoError(err)
			require.EqualValues(iotextypes.ReceiptStatus_ErrCandidateAlreadyExist, ccto.Status)
			require.NoError(checkCandidateState(sf, candidate1Name, identityset.Address(33).String(), big.NewInt(0), cand1NewVotes, cand1Addr))
		})
		t.Run("candidate transfer ownership to a normal new address again", func(t *testing.T) {
			newOwner2 := identityset.Address(34)
			_, ccto, err := addOneTx(action.SignedCandidateTransferOwnership(8, newOwner2.String(), nil, gasLimit, gasPrice, cand1PriKey, action.WithChainID(chainID)))
			require.NoError(err)
			require.EqualValues(iotextypes.ReceiptStatus_Success, ccto.Status)
			require.NoError(checkCandidateState(sf, candidate1Name, newOwner2.String(), big.NewInt(0), cand1NewVotes, cand1Addr))
		})
		t.Run("candidate transfer ownership to a transfered candidate", func(t *testing.T) {
			newOwner2 := identityset.Address(34)
			_, ccto, err := addOneTx(action.SignedCandidateTransferOwnership(9, newOwner2.String(), nil, gasLimit, gasPrice, cand1PriKey, action.WithChainID(chainID)))
			require.NoError(err)
			require.EqualValues(iotextypes.ReceiptStatus_ErrCandidateAlreadyExist, ccto.Status)
			require.NoError(checkCandidateState(sf, candidate1Name, newOwner2.String(), big.NewInt(0), cand1NewVotes, cand1Addr))
		})
		t.Run("candidate transfer ownership to a contract address", func(t *testing.T) {
			data, _ := hex.DecodeString("608060405234801561001057600080fd5b5060df8061001f6000396000f3006080604052600436106049576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806360fe47b114604e5780636d4ce63c146078575b600080fd5b348015605957600080fd5b5060766004803603810190808035906020019092919050505060a0565b005b348015608357600080fd5b50608a60aa565b6040518082815260200191505060405180910390f35b8060008190555050565b600080549050905600a165627a7a7230582002faabbefbbda99b20217cf33cb8ab8100caf1542bf1f48117d72e2c59139aea0029")
			_, se, err := addOneTx(action.SignedExecution(action.EmptyAddress, cand1PriKey, 10, big.NewInt(0), uint64(100000), big.NewInt(0), data))
			require.NoError(err)
			require.EqualValues(iotextypes.ReceiptStatus_Success, se.Status)
			_, ccto, err := addOneTx(action.SignedCandidateTransferOwnership(11, se.ContractAddress, nil, gasLimit, gasPrice, cand1PriKey, action.WithChainID(chainID)))
			require.NoError(err)
			require.EqualValues(iotextypes.ReceiptStatus_ErrUnknown, ccto.Status)
			require.NoError(checkCandidateState(sf, candidate1Name, identityset.Address(34).String(), big.NewInt(0), cand1NewVotes, cand1Addr))
		})
		t.Run("candidate transfer ownership to an invalid address", func(t *testing.T) {
			_, _, err := addOneTx(action.SignedCandidateTransferOwnership(12, "123", nil, gasLimit, gasPrice, cand1PriKey, action.WithChainID(chainID)))
			require.ErrorContains(err, action.ErrAddress.Error())
		})
		t.Run("candidate transfer ownership with none candidate", func(t *testing.T) {
			newOwner := identityset.Address(34)
			_, _, err := addOneTx(action.SignedCandidateTransferOwnership(12, newOwner.String(), nil, gasLimit, gasPrice, identityset.PrivateKey(12), action.WithChainID(chainID)))
			require.ErrorContains(err, "failed to find receipt")
		})
	}

	cfg := config.Default
	initDBPaths(require, &cfg)
	defer func() {
		clearDBPaths(&cfg)
		// clear the gateway
		delete(cfg.Plugins, config.GatewayPlugin)
	}()

	cfg.ActPool.MinGasPriceStr = "0"
	cfg.Chain.TrieDBPatchFile = ""
	cfg.Consensus.Scheme = config.NOOPScheme
	cfg.Chain.EnableAsyncIndexWrite = false
	cfg.Genesis.BootstrapCandidates = testInitCands
	cfg.Genesis.FbkMigrationBlockHeight = 1
	cfg.Genesis.TsunamiBlockHeight = 2
	cfg.Genesis.EndorsementWithdrawWaitingBlocks = 10
	cfg.Genesis.UpernavikBlockHeight = 3 // enable CandidateIdentifiedByOwner feature

	t.Run("test native staking", func(t *testing.T) {
		testNativeStaking(cfg, t)
	})
}

func checkCandidateState(
	sr protocol.StateReader,
	expectedName,
	expectedOwnerAddr string,
	expectedSelfStake,
	expectedVotes *big.Int,
	candidateAddr address.Address,
) error {
	var cand staking.Candidate
	if _, err := sr.State(&cand, protocol.NamespaceOption(_candidateNameSpace), protocol.KeyOption(candidateAddr.Bytes())); err != nil {
		return err
	}
	if expectedName != cand.Name {
		return errors.New("name does not match")
	}
	if expectedOwnerAddr != cand.Owner.String() {
		return errors.New("Owner address does not match")
	}
	if expectedSelfStake.Cmp(cand.SelfStake) != 0 {
		return errors.New("self stake does not match")
	}
	if expectedVotes.Cmp(cand.Votes) != 0 {
		return errors.Errorf("votes does not match, expected: %s, actual: %s", expectedVotes.String(), cand.Votes.String())
	}
	return nil
}

func checkAccountState(
	cfg config.Config,
	sr protocol.StateReader,
	act *action.SealedEnvelope,
	registrationFee bool,
	expectedBalance *big.Int,
	accountAddr address.Address,
) error {
	cost, err := act.Cost()
	if err != nil {
		return err
	}
	if registrationFee {
		regFee, ok := new(big.Int).SetString(cfg.Genesis.RegistrationConsts.Fee, 10)
		if !ok {
			return errors.New("failed to set genesis registration fee")
		}
		cost.Add(cost, regFee)
	}
	acct1, err := accountutil.LoadAccount(sr, accountAddr)
	if err != nil {
		return err
	}
	if expectedBalance.Cmp(cost.Add(cost, acct1.Balance)) != 0 {
		return errors.New("balance does not match")
	}
	return nil
}

func TestCandidateTransferOwnership(t *testing.T) {
	require := require.New(t)
	initCfg := func() config.Config {
		cfg := deepcopy.Copy(config.Default).(config.Config)
		initDBPaths(require, &cfg)

		cfg.ActPool.MinGasPriceStr = "0"
		cfg.Chain.TrieDBPatchFile = ""
		cfg.Consensus.Scheme = config.NOOPScheme
		cfg.Chain.EnableAsyncIndexWrite = false
		cfg.Genesis.InitBalanceMap[identityset.Address(1).String()] = "100000000000000000000000000"
		cfg.Genesis.InitBalanceMap[identityset.Address(2).String()] = "100000000000000000000000000"
		cfg.Genesis.EndorsementWithdrawWaitingBlocks = 10
		cfg.Genesis.TsunamiBlockHeight = 1
		cfg.Genesis.UpernavikBlockHeight = 2 // enable CandidateIdentifiedByOwner feature
		normalizeGenesisHeights(&cfg)
		return cfg
	}
	registerAmount, _ := big.NewInt(0).SetString("1200000000000000000000000", 10)
	gasLimit = uint64(10000000)
	gasPrice = big.NewInt(1)

	t.Run("transfer candidate ownership", func(t *testing.T) {
		test := newE2ETest(t, initCfg())
		defer test.teardown()
		oldOwnerID := 1
		newOwnerID := 2
		chainID := test.cfg.Chain.ID
		test.run([]*testcase{
			{
				name: "success to transfer candidate ownership",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), "cand1", identityset.Address(1).String(), identityset.Address(1).String(), identityset.Address(oldOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
				},
				act:    &actionWithTime{mustNoErr(action.SignedCandidateTransferOwnership(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), identityset.Address(newOwnerID).String(), nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{successExpect, &candidateExpect{"cand1", &iotextypes.CandidateV2{Name: "cand1", OperatorAddress: identityset.Address(1).String(), RewardAddress: identityset.Address(1).String(), TotalWeightedVotes: "1245621408203087110422302", SelfStakingTokens: "0", OwnerAddress: identityset.Address(newOwnerID).String(), SelfStakeBucketIdx: math.MaxUint64}}},
			},
			{
				name:   "transfer back to old owner",
				act:    &actionWithTime{mustNoErr(action.SignedCandidateTransferOwnership(test.nonceMgr.pop(identityset.Address(newOwnerID).String()), identityset.Address(oldOwnerID).String(), nil, gasLimit, gasPrice, identityset.PrivateKey(newOwnerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{successExpect, &candidateExpect{"cand1", &iotextypes.CandidateV2{Name: "cand1", OperatorAddress: identityset.Address(1).String(), RewardAddress: identityset.Address(1).String(), TotalWeightedVotes: "1245621408203087110422302", SelfStakingTokens: "0", OwnerAddress: identityset.Address(oldOwnerID).String(), SelfStakeBucketIdx: math.MaxUint64}}},
			},
		})
	})
	t.Run("candidate activate after transfer candidate ownership", func(t *testing.T) {
		test := newE2ETest(t, initCfg())
		defer test.teardown()

		oldOwnerID := 1
		newOwnerID := 2
		chainID := test.cfg.Chain.ID

		test.run([]*testcase{
			{
				name: "old owner cannot invoke candidate activate",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), "cand1", identityset.Address(1).String(), identityset.Address(1).String(), identityset.Address(oldOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCandidateTransferOwnership(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), identityset.Address(newOwnerID).String(), nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCreateStake(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), "cand1", registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
				},
				act:    &actionWithTime{mustNoErr(action.SignedCandidateActivate(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), 1, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrCandidateNotExist), ""}},
			},
			{
				name: "new owner can invoke candidate activate",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedCreateStake(test.nonceMgr.pop(identityset.Address(newOwnerID).String()), "cand1", registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(newOwnerID), action.WithChainID(chainID))), time.Now()},
				},
				act:    &actionWithTime{mustNoErr(action.SignedCandidateActivate(test.nonceMgr.pop(identityset.Address(newOwnerID).String()), 2, gasLimit, gasPrice, identityset.PrivateKey(newOwnerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{successExpect, &candidateExpect{"cand1", &iotextypes.CandidateV2{Name: "cand1", OperatorAddress: identityset.Address(1).String(), RewardAddress: identityset.Address(1).String(), TotalWeightedVotes: "3736864224609261331266906", SelfStakingTokens: registerAmount.String(), OwnerAddress: identityset.Address(newOwnerID).String(), SelfStakeBucketIdx: 2}}},
			},
		})
	})
	t.Run("candidate endorsement after transfer candidate ownership", func(t *testing.T) {
		test := newE2ETest(t, initCfg())
		defer test.teardown()

		oldOwnerID := 1
		newOwnerID := 2
		stakerID := 3
		chainID := test.cfg.Chain.ID
		stakeTime := time.Now()

		test.run([]*testcase{
			{
				name: "endorse same candidate after transfer ownership",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), "cand1", identityset.Address(1).String(), identityset.Address(1).String(), identityset.Address(oldOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCreateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), "cand1", registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), stakeTime},
					{mustNoErr(action.SignedCandidateTransferOwnership(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), identityset.Address(newOwnerID).String(), nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
				},
				act:    &actionWithTime{mustNoErr(action.SignedCandidateEndorsementLegacy(test.nonceMgr.pop(identityset.Address(stakerID).String()), 1, true, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{successExpect, &bucketExpect{&iotextypes.VoteBucket{Index: 1, CandidateAddress: identityset.Address(oldOwnerID).String(), StakedAmount: registerAmount.String(), AutoStake: true, StakedDuration: 1, CreateTime: timestamppb.New(stakeTime), StakeStartTime: timestamppb.New(stakeTime), UnstakeStartTime: &timestamppb.Timestamp{}, Owner: identityset.Address(stakerID).String(), ContractAddress: "", EndorsementExpireBlockHeight: math.MaxUint64}}},
			},
		})
	})
	t.Run("candidate register after transfer candidate ownership", func(t *testing.T) {
		test := newE2ETest(t, initCfg())
		defer test.teardown()

		oldOwnerID := 1
		newOwnerID := 2
		newOwnerID2 := 3
		chainID := test.cfg.Chain.ID

		test.run([]*testcase{
			{
				name: "old owner can register again after ownership transfer",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), "cand1", identityset.Address(1).String(), identityset.Address(1).String(), identityset.Address(oldOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCandidateTransferOwnership(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), identityset.Address(newOwnerID).String(), nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
				},
				act:    &actionWithTime{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), "cand2", identityset.Address(2).String(), identityset.Address(1).String(), identityset.Address(oldOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrCandidateAlreadyExist), ""}},
			},
			{
				name:   "new owner cannot register again",
				act:    &actionWithTime{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(newOwnerID).String()), "cand2", identityset.Address(2).String(), identityset.Address(1).String(), identityset.Address(newOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(newOwnerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrCandidateAlreadyExist), ""}},
			},
			{
				name:   "transfer ownership to another new owner",
				act:    &actionWithTime{mustNoErr(action.SignedCandidateTransferOwnership(test.nonceMgr.pop(identityset.Address(newOwnerID).String()), identityset.Address(newOwnerID2).String(), nil, gasLimit, gasPrice, identityset.PrivateKey(newOwnerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{successExpect, &candidateExpect{"cand1", &iotextypes.CandidateV2{Name: "cand1", OperatorAddress: identityset.Address(1).String(), RewardAddress: identityset.Address(1).String(), TotalWeightedVotes: "1245621408203087110422302", SelfStakingTokens: "0", OwnerAddress: identityset.Address(newOwnerID2).String(), SelfStakeBucketIdx: math.MaxUint64}}},
			},
			{
				name:   "new owner can register again",
				act:    &actionWithTime{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(newOwnerID).String()), "cand3", identityset.Address(3).String(), identityset.Address(1).String(), identityset.Address(newOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(newOwnerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{successExpect, &candidateExpect{"cand3", &iotextypes.CandidateV2{Name: "cand3", OperatorAddress: identityset.Address(3).String(), RewardAddress: identityset.Address(1).String(), TotalWeightedVotes: "1245621408203087110422302", SelfStakingTokens: registerAmount.String(), OwnerAddress: identityset.Address(newOwnerID).String(), SelfStakeBucketIdx: 1}}},
			},
		})
	})
	t.Run("candidate update after transfer candidate ownership", func(t *testing.T) {
		test := newE2ETest(t, initCfg())
		defer test.teardown()

		oldOwnerID := 1
		newOwnerID := 2
		chainID := test.cfg.Chain.ID

		test.run([]*testcase{
			{
				name: "old owner cannot update",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), "cand1", identityset.Address(1).String(), identityset.Address(1).String(), identityset.Address(oldOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCandidateTransferOwnership(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), identityset.Address(newOwnerID).String(), nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
				},
				act:    &actionWithTime{mustNoErr(action.SignedCandidateUpdate(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), "cand2", identityset.Address(2).String(), identityset.Address(1).String(), gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrCandidateNotExist), ""}},
			},
			{
				name:   "new owner can update",
				act:    &actionWithTime{mustNoErr(action.SignedCandidateUpdate(test.nonceMgr.pop(identityset.Address(newOwnerID).String()), "cand2", identityset.Address(2).String(), identityset.Address(1).String(), gasLimit, gasPrice, identityset.PrivateKey(newOwnerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{successExpect, &candidateExpect{"cand2", &iotextypes.CandidateV2{Name: "cand2", OperatorAddress: identityset.Address(2).String(), RewardAddress: identityset.Address(1).String(), TotalWeightedVotes: "1245621408203087110422302", SelfStakingTokens: "0", OwnerAddress: identityset.Address(newOwnerID).String(), SelfStakeBucketIdx: math.MaxUint64}}},
			},
		})
	})
	t.Run("stake change candidate after transfer candidate ownership", func(t *testing.T) {
		test := newE2ETest(t, initCfg())
		defer test.teardown()

		oldOwnerID := 1
		newOwnerID := 2
		stakerID := 3
		chainID := test.cfg.Chain.ID
		stakeTime := time.Now()

		test.run([]*testcase{
			{
				name: "change candidate after transfer ownership",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), "cand1", identityset.Address(1).String(), identityset.Address(1).String(), identityset.Address(oldOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCandidateTransferOwnership(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), identityset.Address(newOwnerID).String(), nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(stakerID).String()), "cand2", identityset.Address(2).String(), identityset.Address(1).String(), identityset.Address(stakerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCreateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), "cand2", registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), stakeTime},
				},
				act: &actionWithTime{mustNoErr(action.SignedChangeCandidate(test.nonceMgr.pop(identityset.Address(stakerID).String()), "cand1", 2, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{
					successExpect,
					&bucketExpect{&iotextypes.VoteBucket{Index: 2, CandidateAddress: identityset.Address(oldOwnerID).String(), StakedAmount: registerAmount.String(), AutoStake: true, StakedDuration: 1, CreateTime: timestamppb.New(stakeTime), StakeStartTime: timestamppb.New(stakeTime), UnstakeStartTime: &timestamppb.Timestamp{}, Owner: identityset.Address(stakerID).String(), ContractAddress: "", EndorsementExpireBlockHeight: 0}},
					&candidateExpect{"cand1", &iotextypes.CandidateV2{Name: "cand1", OperatorAddress: identityset.Address(1).String(), RewardAddress: identityset.Address(1).String(), TotalWeightedVotes: "2491242816406174220844604", SelfStakingTokens: "0", OwnerAddress: identityset.Address(newOwnerID).String(), SelfStakeBucketIdx: math.MaxUint64}},
					&candidateExpect{"cand2", &iotextypes.CandidateV2{Name: "cand2", OperatorAddress: identityset.Address(2).String(), RewardAddress: identityset.Address(1).String(), TotalWeightedVotes: "1245621408203087110422302", SelfStakingTokens: registerAmount.String(), OwnerAddress: identityset.Address(stakerID).String(), SelfStakeBucketIdx: 1}},
				},
			},
		})
	})
	t.Run("stake create after transfer candidate ownership", func(t *testing.T) {
		test := newE2ETest(t, initCfg())
		defer test.teardown()

		oldOwnerID := 1
		newOwnerID := 2
		stakerID := 3
		chainID := test.cfg.Chain.ID
		stakeTime := time.Now()

		test.run([]*testcase{
			{
				name: "create stake after transfer ownership",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), "cand1", identityset.Address(1).String(), identityset.Address(1).String(), identityset.Address(oldOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCandidateTransferOwnership(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), identityset.Address(newOwnerID).String(), nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
				},
				act: &actionWithTime{mustNoErr(action.SignedCreateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), "cand1", registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), stakeTime},
				expect: []actionExpect{
					successExpect,
					&bucketExpect{&iotextypes.VoteBucket{Index: 1, CandidateAddress: identityset.Address(oldOwnerID).String(), StakedAmount: registerAmount.String(), AutoStake: true, StakedDuration: 1, CreateTime: timestamppb.New(stakeTime), StakeStartTime: timestamppb.New(stakeTime), UnstakeStartTime: &timestamppb.Timestamp{}, Owner: identityset.Address(stakerID).String(), ContractAddress: "", EndorsementExpireBlockHeight: 0}},
				},
			},
		})
	})
	t.Run("migrate stake", func(t *testing.T) {
		contractAddress := "io1dkqh5mu9djfas3xyrmzdv9frsmmytel4mp7a64"
		cfg := initCfg()
		cfg.Genesis.SystemStakingContractV2Address = contractAddress
		cfg.Genesis.SystemStakingContractV2Height = 1
		cfg.DardanellesUpgrade.BlockInterval = time.Second * 8640
		cfg.Plugins[config.GatewayPlugin] = nil
		test := newE2ETest(t, cfg)
		defer test.teardown()

		chainID := test.cfg.Chain.ID
		stakerID := 1
		stakeAmount, _ := big.NewInt(0).SetString("10000000000000000000000", 10)
		stakeDurationDays := uint32(1) // 1day
		stakeTime := time.Now()
		candOwnerID := 2
		blocksPerDay := 24 * time.Hour / cfg.DardanellesUpgrade.BlockInterval
		balance := big.NewInt(0)
		h := identityset.Address(1).String()
		t.Logf("address 1: %v\n", h)
		minAmount, _ := big.NewInt(0).SetString("1000000000000000000000", 10) // 1000 IOTX
		deployCode, err := staking.StakingContractABI.Constructor.Inputs.Pack(minAmount, common.BytesToAddress(identityset.Address(stakerID).Bytes()))
		deployCode = append(stakingContractBytecode, deployCode...)
		require.NoError(err)
		test.run([]*testcase{
			{
				name: "deploy staking contract",
				act:  &actionWithTime{mustNoErr(action.SignedExecution("", identityset.PrivateKey(stakerID), test.nonceMgr.pop(identityset.Address(stakerID).String()), big.NewInt(0), gasLimit, gasPrice, deployCode, action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{
					successExpect, &executionExpect{contractAddress},
					&accountExpect{identityset.Address(stakerID), "99999999999999999996387414", test.nonceMgr[identityset.Address(stakerID).String()]},
				},
			},
			{
				name: "non-owner cannot migrate stake",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(candOwnerID).String()), "cand1", identityset.Address(1).String(), identityset.Address(1).String(), identityset.Address(candOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(candOwnerID), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCreateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), "cand1", stakeAmount.String(), stakeDurationDays, true, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), stakeTime},
				},
				act: &actionWithTime{mustNoErr(action.SignedMigrateStake(test.nonceMgr.pop(identityset.Address(2).String()), 1, gasLimit, gasPrice, identityset.PrivateKey(2), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{
					&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrUnauthorizedOperator), ""},
					&bucketExpect{&iotextypes.VoteBucket{Index: 1, CandidateAddress: identityset.Address(candOwnerID).String(), StakedAmount: stakeAmount.String(), AutoStake: true, StakedDuration: stakeDurationDays, Owner: identityset.Address(stakerID).String(), CreateTime: timestamppb.New(stakeTime), StakeStartTime: timestamppb.New(stakeTime), UnstakeStartTime: &timestamppb.Timestamp{}}},
					&accountExpect{identityset.Address(stakerID), "99989999999999999996377414", test.nonceMgr[identityset.Address(stakerID).String()]},
					&candidateExpect{"cand1", &iotextypes.CandidateV2{Name: "cand1", OperatorAddress: identityset.Address(1).String(), RewardAddress: identityset.Address(1).String(), TotalWeightedVotes: "1256001586604779503009155", SelfStakingTokens: registerAmount.String(), OwnerAddress: identityset.Address(candOwnerID).String(), SelfStakeBucketIdx: 0}},
				},
			},
			{
				name: "success to migrate stake",
				preFunc: func(e *e2etest) {
					// get balance before migration
					resp, err := e.api.GetAccount(context.Background(), &iotexapi.GetAccountRequest{
						Address: identityset.Address(stakerID).String(),
					})
					require.NoError(err)
					b, ok := big.NewInt(0).SetString(resp.GetAccountMeta().GetBalance(), 10)
					require.True(ok)
					balance = b
				},
				act: &actionWithTime{mustNoErr(action.SignedMigrateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), 1, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{
					successExpect,
					&fullActionExpect{
						address.StakingProtocolAddr, 212034,
						[]*action.TransactionLog{
							{
								Type:      iotextypes.TransactionLogType_GAS_FEE,
								Amount:    big.NewInt(int64(action.MigrateStakeBaseIntrinsicGas)),
								Sender:    identityset.Address(stakerID).String(),
								Recipient: address.RewardingPoolAddr,
							},
							{
								Type:      iotextypes.TransactionLogType_WITHDRAW_BUCKET,
								Amount:    stakeAmount,
								Sender:    address.StakingBucketPoolAddr,
								Recipient: identityset.Address(stakerID).String(),
							},
							{
								Type:      iotextypes.TransactionLogType_GAS_FEE,
								Amount:    big.NewInt(202034),
								Sender:    identityset.Address(stakerID).String(),
								Recipient: address.RewardingPoolAddr,
							},
							{
								Type:      iotextypes.TransactionLogType_IN_CONTRACT_TRANSFER,
								Amount:    stakeAmount,
								Sender:    identityset.Address(stakerID).String(),
								Recipient: contractAddress,
							},
						},
					},
					&bucketExpect{&iotextypes.VoteBucket{Index: 1, CandidateAddress: identityset.Address(candOwnerID).String(), StakedAmount: stakeAmount.String(), AutoStake: true, StakedDuration: stakeDurationDays, StakedDurationBlockNumber: uint64(stakeDurationDays) * uint64(blocksPerDay), CreateBlockHeight: 5, StakeStartBlockHeight: 5, UnstakeStartBlockHeight: math.MaxUint64, Owner: identityset.Address(stakerID).String(), ContractAddress: contractAddress, CreateTime: timestamppb.New(time.Time{}), StakeStartTime: timestamppb.New(time.Time{}), UnstakeStartTime: timestamppb.New(time.Time{})}},
					&noBucketExpect{1, ""},
					&accountExpect{identityset.Address(stakerID), "99989999999999999996165380", test.nonceMgr[identityset.Address(stakerID).String()]},
					&candidateExpect{"cand1", &iotextypes.CandidateV2{Name: "cand1", OperatorAddress: identityset.Address(1).String(), RewardAddress: identityset.Address(1).String(), TotalWeightedVotes: "1256001586604779503009155", SelfStakingTokens: registerAmount.String(), OwnerAddress: identityset.Address(candOwnerID).String(), SelfStakeBucketIdx: 0}},
					&functionExpect{func(test *e2etest, act *action.SealedEnvelope, receipt *action.Receipt, err error) {
						resp, err := test.api.GetAccount(context.Background(), &iotexapi.GetAccountRequest{
							Address: identityset.Address(stakerID).String(),
						})
						require.NoError(err)
						postBalance, ok := big.NewInt(0).SetString(resp.GetAccountMeta().GetBalance(), 10)
						require.True(ok)
						gasInLog := big.NewInt(0)
						for _, l := range receipt.TransactionLogs() {
							if l.Type == iotextypes.TransactionLogType_GAS_FEE {
								gasInLog.Add(gasInLog, l.Amount)
							}
						}
						gasFee := big.NewInt(0).Mul(big.NewInt(int64(receipt.GasConsumed)), gasPrice)
						// sum of gas in logs = gas consumed of receipt
						require.Equal(gasInLog, gasFee)
						// balance = preBalance - gasFee
						require.Equal(balance.Sub(balance, gasFee).String(), postBalance.String())
					}},
				},
			},
			{
				name: "stake",
				act:  &actionWithTime{mustNoErr(action.SignedCreateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), "cand1", unit.ConvertIotxToRau(100).String(), stakeDurationDays, true, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), stakeTime},
				expect: []actionExpect{
					successExpect,
					&bucketExpect{&iotextypes.VoteBucket{Index: 2, CandidateAddress: identityset.Address(candOwnerID).String(), StakedAmount: unit.ConvertIotxToRau(100).String(), AutoStake: true, StakedDuration: stakeDurationDays, Owner: identityset.Address(stakerID).String(), CreateTime: timestamppb.New(stakeTime), StakeStartTime: timestamppb.New(stakeTime), UnstakeStartTime: &timestamppb.Timestamp{}}},
					&accountExpect{identityset.Address(stakerID), "99989899999999999996155380", test.nonceMgr[identityset.Address(stakerID).String()]},
				},
			},
			{
				name:    "contract call failure",
				preActs: []*actionWithTime{},
				act:     &actionWithTime{mustNoErr(action.SignedMigrateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), 2, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{
					&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrExecutionReverted), ""},
					&fullActionExpect{
						address.StakingProtocolAddr, 29425, []*action.TransactionLog{
							{
								Type:      iotextypes.TransactionLogType_GAS_FEE,
								Amount:    big.NewInt(29425),
								Sender:    identityset.Address(stakerID).String(),
								Recipient: address.RewardingPoolAddr,
							},
						},
					},
					&bucketExpect{&iotextypes.VoteBucket{Index: 2, CandidateAddress: identityset.Address(candOwnerID).String(), StakedAmount: unit.ConvertIotxToRau(100).String(), AutoStake: true, StakedDuration: stakeDurationDays, Owner: identityset.Address(stakerID).String(), CreateTime: timestamppb.New(stakeTime), StakeStartTime: timestamppb.New(stakeTime), UnstakeStartTime: &timestamppb.Timestamp{}}},
					&accountExpect{identityset.Address(stakerID), "99989899999999999996125955", test.nonceMgr[identityset.Address(stakerID).String()]},
				},
			},
			{
				name: "self-stake bucket cannot be migrated",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(candOwnerID).String()), "cand1", identityset.Address(1).String(), identityset.Address(1).String(), identityset.Address(candOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(candOwnerID), action.WithChainID(chainID))), time.Now()},
				},
				act: &actionWithTime{mustNoErr(action.SignedMigrateStake(test.nonceMgr.pop(identityset.Address(candOwnerID).String()), 0, gasLimit, gasPrice, identityset.PrivateKey(candOwnerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{
					&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrInvalidBucketType), ""},
				},
			},
			{
				name: "unstaked bucket cannot be migrated",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedCreateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), "cand1", unit.ConvertIotxToRau(100).String(), stakeDurationDays, false, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), stakeTime},
					{mustNoErr(action.SignedReclaimStake(false, test.nonceMgr.pop(identityset.Address(stakerID).String()), 3, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				},
				act: &actionWithTime{mustNoErr(action.SignedMigrateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), 3, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{
					&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrInvalidBucketType), ""},
				},
			},
			{
				name: "non auto-stake bucket cannot be migrated",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedCreateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), "cand1", unit.ConvertIotxToRau(100).String(), stakeDurationDays, false, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), stakeTime},
				},
				act: &actionWithTime{mustNoErr(action.SignedMigrateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), 4, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{
					&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrInvalidBucketType), ""},
				},
			},
			{
				name: "endorsement bucket cannot be migrated",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(candOwnerID).String()), "cand1", identityset.Address(1).String(), identityset.Address(1).String(), identityset.Address(candOwnerID).String(), "0", 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(candOwnerID), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCreateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), "cand1", registerAmount.String(), 91, true, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), stakeTime},
					{mustNoErr(action.SignedCandidateEndorsement(test.nonceMgr.pop(identityset.Address(stakerID).String()), 5, action.CandidateEndorsementOpEndorse, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				},
				act: &actionWithTime{mustNoErr(action.SignedMigrateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), 5, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{
					&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrInvalidBucketType), ""},
				},
			},
			{
				name: "estimateGas",
				act:  &actionWithTime{mustNoErr(action.SignedCreateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), "cand1", stakeAmount.String(), stakeDurationDays, true, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), stakeTime},
				expect: []actionExpect{&functionExpect{func(test *e2etest, act *action.SealedEnvelope, receipt *action.Receipt, err error) {
					ms, err := action.NewMigrateStake(0, 3, gasLimit, gasPrice)
					require.NoError(err)
					resp, err := test.api.EstimateActionGasConsumption(context.Background(), &iotexapi.EstimateActionGasConsumptionRequest{
						Action:        &iotexapi.EstimateActionGasConsumptionRequest_StakeMigrate{StakeMigrate: ms.Proto()},
						CallerAddress: identityset.Address(3).String(),
						GasPrice:      gasPrice.String(),
					})
					require.NoError(err)
					require.Equal(uint64(194934), resp.Gas)
				}}},
			},
		})
	})
	t.Run("new endorsement", func(t *testing.T) {
		cfg := initCfg()
		cfg.Genesis.UpernavikBlockHeight = 6
		cfg.Genesis.EndorsementWithdrawWaitingBlocks = 5
		test := newE2ETest(t, cfg)
		defer test.teardown()

		var (
			candOwnerID  = 1
			stakerID     = 2
			candOwnerID2 = 3
			chainID      = test.cfg.Chain.ID
			stakeTime    = time.Now()
		)
		test.run([]*testcase{
			{
				name: "endorse action disabled before UpernavikBlockHeight",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(candOwnerID).String()), "cand1", identityset.Address(1).String(), identityset.Address(1).String(), identityset.Address(candOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(candOwnerID), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCreateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), "cand1", registerAmount.String(), 91, true, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), stakeTime},
				},
				act:    &actionWithTime{mustNoErr(action.SignedCandidateEndorsement(test.nonceMgr[(identityset.Address(stakerID).String())], 1, action.CandidateEndorsementOpEndorse, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{&basicActionExpect{errReceiptNotFound, 0, ""}},
			},
			{
				name:   "intentToRevokeEndorsement action disabled before UpernavikBlockHeight",
				act:    &actionWithTime{mustNoErr(action.SignedCandidateEndorsement(test.nonceMgr[(identityset.Address(stakerID).String())], 1, action.CandidateEndorsementOpIntentToRevoke, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{&basicActionExpect{errReceiptNotFound, 0, ""}},
			},
			{
				name:   "revokeEndorsement action disabled before UpernavikBlockHeight",
				act:    &actionWithTime{mustNoErr(action.SignedCandidateEndorsement(test.nonceMgr[(identityset.Address(stakerID).String())], 1, action.CandidateEndorsementOpRevoke, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{&basicActionExpect{errReceiptNotFound, 0, ""}},
			},
			{
				name:   "endorse action disabled after UpernavikBlockHeight",
				act:    &actionWithTime{mustNoErr(action.SignedCandidateEndorsement(test.nonceMgr.pop(identityset.Address(stakerID).String()), 1, action.CandidateEndorsementOpEndorse, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{successExpect},
			},
			{
				name: "cannot change candidate after bucket is endorsed",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(candOwnerID2).String()), "cand2", identityset.Address(3).String(), identityset.Address(3).String(), identityset.Address(candOwnerID2).String(), "0", 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(candOwnerID2), action.WithChainID(chainID))), time.Now()},
				},
				act:    &actionWithTime{mustNoErr(action.SignedChangeCandidate(test.nonceMgr.pop(identityset.Address(stakerID).String()), "cand2", 1, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrInvalidBucketType), ""}},
			},
			{
				name:   "cannot migrate after bucket is endorsed",
				act:    &actionWithTime{mustNoErr(action.SignedMigrateStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), 1, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrInvalidBucketType), ""}},
			},
			{
				name:   "cannot unstake after bucket is endorsed",
				act:    &actionWithTime{mustNoErr(action.SignedReclaimStake(false, test.nonceMgr.pop(identityset.Address(stakerID).String()), 1, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrInvalidBucketType), ""}},
			},
			{
				name:   "cannot revoke before endorsement expire",
				act:    &actionWithTime{mustNoErr(action.SignedCandidateEndorsement(test.nonceMgr.pop(identityset.Address(stakerID).String()), 1, action.CandidateEndorsementOpRevoke, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrInvalidBucketType), ""}},
			},
			{
				name: "intentToRevoke now if endorsement is not used",
				act:  &actionWithTime{mustNoErr(action.SignedCandidateEndorsement(test.nonceMgr.pop(identityset.Address(stakerID).String()), 1, action.CandidateEndorsementOpIntentToRevoke, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{
					successExpect,
					&bucketExpect{&iotextypes.VoteBucket{Index: 1, EndorsementExpireBlockHeight: 12, CandidateAddress: identityset.Address(candOwnerID).String(), StakedAmount: registerAmount.String(), AutoStake: true, StakedDuration: 91, Owner: identityset.Address(stakerID).String(), CreateTime: timestamppb.New(stakeTime), StakeStartTime: timestamppb.New(stakeTime), UnstakeStartTime: &timestamppb.Timestamp{}}},
				},
			},
			{
				name: "revoke success",
				act:  &actionWithTime{mustNoErr(action.SignedCandidateEndorsement(test.nonceMgr.pop(identityset.Address(stakerID).String()), 1, action.CandidateEndorsementOpRevoke, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{
					successExpect,
					&bucketExpect{&iotextypes.VoteBucket{Index: 1, EndorsementExpireBlockHeight: 0, CandidateAddress: identityset.Address(candOwnerID).String(), StakedAmount: registerAmount.String(), AutoStake: true, StakedDuration: 91, Owner: identityset.Address(stakerID).String(), CreateTime: timestamppb.New(stakeTime), StakeStartTime: timestamppb.New(stakeTime), UnstakeStartTime: &timestamppb.Timestamp{}}},
				},
			},
			{
				name: "intentToRevoke if endorsement is used",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedChangeCandidate(test.nonceMgr.pop(identityset.Address(stakerID).String()), "cand2", 1, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCandidateEndorsement(test.nonceMgr.pop(identityset.Address(stakerID).String()), 1, action.CandidateEndorsementOpEndorse, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCandidateActivate(test.nonceMgr.pop(identityset.Address(candOwnerID2).String()), 1, gasLimit, gasPrice, identityset.PrivateKey(candOwnerID2), action.WithChainID(chainID))), time.Now()},
				},
				act: &actionWithTime{mustNoErr(action.SignedCandidateEndorsement(test.nonceMgr.pop(identityset.Address(stakerID).String()), 1, action.CandidateEndorsementOpIntentToRevoke, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{
					successExpect,
					&bucketExpect{&iotextypes.VoteBucket{Index: 1, EndorsementExpireBlockHeight: 22, CandidateAddress: identityset.Address(candOwnerID2).String(), StakedAmount: registerAmount.String(), AutoStake: true, StakedDuration: 91, Owner: identityset.Address(stakerID).String(), CreateTime: timestamppb.New(stakeTime), StakeStartTime: timestamppb.New(stakeTime), UnstakeStartTime: &timestamppb.Timestamp{}}},
					&candidateExpect{"cand2", &iotextypes.CandidateV2{Name: "cand2", OperatorAddress: identityset.Address(3).String(), RewardAddress: identityset.Address(3).String(), TotalWeightedVotes: "1635067133824581908640994", SelfStakingTokens: registerAmount.String(), OwnerAddress: identityset.Address(candOwnerID2).String(), SelfStakeBucketIdx: 1}},
				},
			},
			{
				name:   "cannot revoke before expired",
				act:    &actionWithTime{mustNoErr(action.SignedCandidateEndorsement(test.nonceMgr.pop(identityset.Address(stakerID).String()), 1, action.CandidateEndorsementOpRevoke, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrInvalidBucketType), ""}},
			},
			{
				name: "eligible as proposer after expired",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedTransfer(identityset.Address(1).String(), identityset.PrivateKey(2), test.nonceMgr.pop(identityset.Address(2).String()), unit.ConvertIotxToRau(1), nil, gasLimit, gasPrice, action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedTransfer(identityset.Address(1).String(), identityset.PrivateKey(2), test.nonceMgr.pop(identityset.Address(2).String()), unit.ConvertIotxToRau(1), nil, gasLimit, gasPrice, action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedTransfer(identityset.Address(1).String(), identityset.PrivateKey(2), test.nonceMgr.pop(identityset.Address(2).String()), unit.ConvertIotxToRau(1), nil, gasLimit, gasPrice, action.WithChainID(chainID))), time.Now()},
				},
				act: &actionWithTime{mustNoErr(action.SignedTransfer(identityset.Address(1).String(), identityset.PrivateKey(2), test.nonceMgr.pop(identityset.Address(2).String()), unit.ConvertIotxToRau(1), nil, gasLimit, gasPrice, action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{successExpect,
					&candidateExpect{"cand2", &iotextypes.CandidateV2{Name: "cand2", OperatorAddress: identityset.Address(3).String(), RewardAddress: identityset.Address(3).String(), TotalWeightedVotes: "1635067133824581908640994", SelfStakingTokens: registerAmount.String(), OwnerAddress: identityset.Address(candOwnerID2).String(), SelfStakeBucketIdx: 1}},
				},
			},
			{
				name: "revoke success after expired",
				act:  &actionWithTime{mustNoErr(action.SignedCandidateEndorsement(test.nonceMgr.pop(identityset.Address(stakerID).String()), 1, action.CandidateEndorsementOpRevoke, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{
					successExpect,
					&bucketExpect{&iotextypes.VoteBucket{Index: 1, EndorsementExpireBlockHeight: 0, CandidateAddress: identityset.Address(candOwnerID2).String(), StakedAmount: registerAmount.String(), AutoStake: true, StakedDuration: 91, Owner: identityset.Address(stakerID).String(), CreateTime: timestamppb.New(stakeTime), StakeStartTime: timestamppb.New(stakeTime), UnstakeStartTime: &timestamppb.Timestamp{}}},
					&candidateExpect{"cand2", &iotextypes.CandidateV2{Name: "cand2", OperatorAddress: identityset.Address(3).String(), RewardAddress: identityset.Address(3).String(), TotalWeightedVotes: "1542516163985454635820816", SelfStakingTokens: "0", OwnerAddress: identityset.Address(candOwnerID2).String(), SelfStakeBucketIdx: math.MaxUint64}},
				},
			},
			{
				name: "revoke if endorse bucket is self-owned",
				preActs: []*actionWithTime{
					{mustNoErr(action.SignedTransferStake(test.nonceMgr.pop(identityset.Address(stakerID).String()), identityset.Address(candOwnerID2).String(), 1, nil, gasLimit, gasPrice, identityset.PrivateKey(stakerID), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCandidateEndorsement(test.nonceMgr.pop(identityset.Address(candOwnerID2).String()), 1, action.CandidateEndorsementOpEndorse, gasLimit, gasPrice, identityset.PrivateKey(candOwnerID2), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCandidateActivate(test.nonceMgr.pop(identityset.Address(candOwnerID2).String()), 1, gasLimit, gasPrice, identityset.PrivateKey(candOwnerID2), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedCandidateEndorsement(test.nonceMgr.pop(identityset.Address(candOwnerID2).String()), 1, action.CandidateEndorsementOpIntentToRevoke, gasLimit, gasPrice, identityset.PrivateKey(candOwnerID2), action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedTransfer(identityset.Address(1).String(), identityset.PrivateKey(2), test.nonceMgr.pop(identityset.Address(2).String()), unit.ConvertIotxToRau(1), nil, gasLimit, gasPrice, action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedTransfer(identityset.Address(1).String(), identityset.PrivateKey(2), test.nonceMgr.pop(identityset.Address(2).String()), unit.ConvertIotxToRau(1), nil, gasLimit, gasPrice, action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedTransfer(identityset.Address(1).String(), identityset.PrivateKey(2), test.nonceMgr.pop(identityset.Address(2).String()), unit.ConvertIotxToRau(1), nil, gasLimit, gasPrice, action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedTransfer(identityset.Address(1).String(), identityset.PrivateKey(2), test.nonceMgr.pop(identityset.Address(2).String()), unit.ConvertIotxToRau(1), nil, gasLimit, gasPrice, action.WithChainID(chainID))), time.Now()},
					{mustNoErr(action.SignedTransfer(identityset.Address(1).String(), identityset.PrivateKey(2), test.nonceMgr.pop(identityset.Address(2).String()), unit.ConvertIotxToRau(1), nil, gasLimit, gasPrice, action.WithChainID(chainID))), time.Now()},
				},
				act: &actionWithTime{mustNoErr(action.SignedCandidateEndorsement(test.nonceMgr.pop(identityset.Address(candOwnerID2).String()), 1, action.CandidateEndorsementOpRevoke, gasLimit, gasPrice, identityset.PrivateKey(candOwnerID2), action.WithChainID(chainID))), time.Now()},
				expect: []actionExpect{successExpect,
					&candidateExpect{"cand2", &iotextypes.CandidateV2{Name: "cand2", OperatorAddress: identityset.Address(3).String(), RewardAddress: identityset.Address(3).String(), TotalWeightedVotes: "1542516163985454635820816", SelfStakingTokens: "0", OwnerAddress: identityset.Address(candOwnerID2).String(), SelfStakeBucketIdx: math.MaxUint64}},
				},
			},
		})
	})
}

func TestCandidateOwnerCollision(t *testing.T) {
	require := require.New(t)
	initCfg := func() config.Config {
		cfg := deepcopy.Copy(config.Default).(config.Config)
		initDBPaths(require, &cfg)

		cfg.ActPool.MinGasPriceStr = "0"
		cfg.Chain.TrieDBPatchFile = ""
		cfg.Consensus.Scheme = config.NOOPScheme
		cfg.Chain.EnableAsyncIndexWrite = false
		cfg.Genesis.InitBalanceMap[identityset.Address(1).String()] = "100000000000000000000000000"
		cfg.Genesis.InitBalanceMap[identityset.Address(2).String()] = "100000000000000000000000000"
		cfg.Genesis.EndorsementWithdrawWaitingBlocks = 10
		cfg.Genesis.TsunamiBlockHeight = 1
		cfg.Genesis.UpernavikBlockHeight = 2 // enable CandidateIdentifiedByOwner feature
		normalizeGenesisHeights(&cfg)
		return cfg
	}
	registerAmount, _ := big.NewInt(0).SetString("1200000000000000000000000", 10)
	gasLimit = uint64(10000000)
	gasPrice = big.NewInt(1)
	oldOwnerID := 1
	newOwnerID := 2
	newOwnerID2 := 3
	test := newE2ETest(t, initCfg())
	defer test.teardown()
	chainID := test.cfg.Chain.ID
	test.run([]*testcase{
		{
			name: "owner cannot register again",
			preActs: []*actionWithTime{
				{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), "cand1", identityset.Address(1).String(), identityset.Address(1).String(), identityset.Address(oldOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
			},
			act:    &actionWithTime{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), "cand2", identityset.Address(2).String(), identityset.Address(2).String(), identityset.Address(oldOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
			expect: []actionExpect{&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrCandidateAlreadyExist), ""}},
		},
		{
			name:    "original owner cannot register again",
			preActs: []*actionWithTime{{mustNoErr(action.SignedCandidateTransferOwnership(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), identityset.Address(newOwnerID).String(), nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()}},
			act:     &actionWithTime{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(oldOwnerID).String()), "cand2", identityset.Address(2).String(), identityset.Address(2).String(), identityset.Address(oldOwnerID).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(oldOwnerID), action.WithChainID(chainID))), time.Now()},
			expect:  []actionExpect{&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrCandidateAlreadyExist), ""}},
		},
		{
			name:    "cannot transfer to a new owner that same as an existed candidate identifier",
			preActs: []*actionWithTime{{mustNoErr(action.SignedCandidateRegister(test.nonceMgr.pop(identityset.Address(newOwnerID2).String()), "cand2", identityset.Address(3).String(), identityset.Address(3).String(), identityset.Address(newOwnerID2).String(), registerAmount.String(), 1, true, nil, gasLimit, gasPrice, identityset.PrivateKey(newOwnerID2), action.WithChainID(chainID))), time.Now()}},
			act:     &actionWithTime{mustNoErr(action.SignedCandidateTransferOwnership(test.nonceMgr.pop(identityset.Address(newOwnerID2).String()), identityset.Address(oldOwnerID).String(), nil, gasLimit, gasPrice, identityset.PrivateKey(newOwnerID2), action.WithChainID(chainID))), time.Now()},
			expect:  []actionExpect{&basicActionExpect{nil, uint64(iotextypes.ReceiptStatus_ErrCandidateAlreadyExist), ""}},
		},
	})
}

func normalizeGenesisHeights(cfg *config.Config) {
	heights := []*uint64{
		&cfg.Genesis.PacificBlockHeight,
		&cfg.Genesis.AleutianBlockHeight,
		&cfg.Genesis.BeringBlockHeight,
		&cfg.Genesis.CookBlockHeight,
		&cfg.Genesis.DardanellesBlockHeight,
		&cfg.Genesis.DaytonaBlockHeight,
		&cfg.Genesis.EasterBlockHeight,
		&cfg.Genesis.FbkMigrationBlockHeight,
		&cfg.Genesis.FairbankBlockHeight,
		&cfg.Genesis.GreenlandBlockHeight,
		&cfg.Genesis.HawaiiBlockHeight,
		&cfg.Genesis.IcelandBlockHeight,
		&cfg.Genesis.JutlandBlockHeight,
		&cfg.Genesis.KamchatkaBlockHeight,
		&cfg.Genesis.LordHoweBlockHeight,
		&cfg.Genesis.MidwayBlockHeight,
		&cfg.Genesis.NewfoundlandBlockHeight,
		&cfg.Genesis.OkhotskBlockHeight,
		&cfg.Genesis.PalauBlockHeight,
		&cfg.Genesis.QuebecBlockHeight,
		&cfg.Genesis.RedseaBlockHeight,
		&cfg.Genesis.SumatraBlockHeight,
		&cfg.Genesis.TsunamiBlockHeight,
		&cfg.Genesis.UpernavikBlockHeight,
		&cfg.Genesis.ToBeEnabledBlockHeight,
	}
	for i := len(heights) - 2; i >= 0; i-- {
		if *(heights[i]) > *(heights[i+1]) {
			*(heights[i]) = *(heights[i+1])
		}
	}
}
