// Copyright (c) 2020 IoTeX Foundation
// This is an alpha (internal) release and is not suitable for production. This source code is provided 'as is' and no
// warranties are given as to title or non-infringement, merchantability or fitness for purpose and, to the extent
// permitted by law, all liability for your use of the code is disclaimed. This source code is governed by Apache
// License 2.0 that can be found in the LICENSE file.

package action

import (
	"encoding/hex"
	"encoding/json"

	"github.com/ethereum/go-ethereum/accounts"

	"github.com/iotexproject/go-pkgs/crypto"
	"github.com/iotexproject/iotex-address/address"
)

type (
	// a consignment is a transaction signed by transferee which contains an embedded message signed by transferor
	//
	// transferee: the entity/address to receive the ownership of an asset/object
	// transferor: the entity/address to transfer the ownership of the asset/object
	//
	// the transaction contains 2 part:
	// 1. an embedded message that clearly identifies (1) the transferee, (2) the transferor, (3) nonce of the transferee,
	// and (4) a unique ID of the asset/object to be transferred
	// 2. a payload that constitutes a valid ECC signature of the message, by verifying that:
	// (1) the signature is valid
	// (2) signer matches the transferor in the message
	// (3) signer matches the actual owner of the asset/object
	// (4) asset ID in the message matches the ID of asset/object to be transferred on blockchain
	// (5) nonce in the message matches transferee's nonce on blockchain
	//
	// successful verification of above is considered a consent that transferor does own the asset/object and transfer it
	// to transferee, because transferee was able to present such a valid signature (hence the name "consignment"), which
	// can only be generated by transferor

	// Consignment represents a consignment
	Consignment interface {
		Transferor() address.Address
		Transferee() address.Address
		AssetID() uint64
		TransfereeNonce() uint64
	}

	// ConsignMsg is the consignment message
	ConsignMsg struct {
		Index     int    `json:"index"`
		Nonce     int    `json:"nonce"`
		Recipient string `json:"recipient"`
		Comment   string `json:"comment"`
	}

	consignment struct {
		Msg        string `json:"msg"`
		Sig        string `json:"sig"`
		consignMsg ConsignMsg
		signer     address.Address
		recipient  address.Address
	}
)

// NewConsignment creates a consignment from data
func NewConsignment(data []byte) (Consignment, error) {
	c := consignment{}
	if err := json.Unmarshal(data, &c); err != nil {
		return nil, err
	}

	// verify signature
	sig, err := hex.DecodeString(c.Sig)
	if err != nil {
		return nil, err
	}
	pk, err := RecoverPubkeyFromEccSig([]byte(c.Msg), sig)
	if err != nil {
		return nil, err
	}
	c.signer, err = address.FromBytes(pk.Hash())
	if err != nil {
		return nil, err
	}

	// parse embedded msg
	if err := json.Unmarshal([]byte(c.Msg), &c.consignMsg); err != nil {
		return nil, err
	}
	c.recipient, err = address.FromString(c.consignMsg.Recipient)
	if err != nil {
		return nil, err
	}
	return &c, nil
}

func (c *consignment) Transferor() address.Address {
	return c.signer
}

func (c *consignment) Transferee() address.Address {
	return c.recipient
}

func (c *consignment) AssetID() uint64 {
	return uint64(c.consignMsg.Index)
}

func (c *consignment) TransfereeNonce() uint64 {
	return uint64(c.consignMsg.Nonce)
}

// RecoverPubkeyFromEccSig recovers public key from ECC signature
func RecoverPubkeyFromEccSig(msg, sig []byte) (crypto.PublicKey, error) {
	h := msgHash(msg)
	for i := range h {
		pk, err := crypto.RecoverPubkey(h[i], sig)
		if err != nil {
			continue
		}
		if pk.Verify(h[i], sig) {
			return pk, nil
		}
	}
	return nil, crypto.ErrInvalidKey
}

func msgHash(msg []byte) [][]byte {
	h1, _ := accounts.TextAndHash(msg) // Ethereum's way to calculate hash for the given message
	// TODO: add hash calculation for other ECC algorithms or coins
	return [][]byte{h1}
}
