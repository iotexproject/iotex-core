diff --git a/action/protocol/execution/evm/evmstatedbadapter.go b/action/protocol/execution/evm/evmstatedbadapter.go
index ba9ce079..08f71047 100644
--- a/action/protocol/execution/evm/evmstatedbadapter.go
+++ b/action/protocol/execution/evm/evmstatedbadapter.go
@@ -24,6 +24,8 @@ import (
 	"github.com/iotexproject/iotex-core/pkg/hash"
 	"github.com/iotexproject/iotex-core/pkg/log"
 	"github.com/iotexproject/iotex-core/state"
+	"encoding/hex"
+	"sort"
 )
 
 type (
@@ -560,7 +562,13 @@ func (stateDB *StateDBAdapter) getContractState(addr hash.Hash160, key hash.Hash
 // setContractState writes contract's storage value
 func (stateDB *StateDBAdapter) setContractState(addr hash.Hash160, key, value hash.Hash256) error {
 	if contract, ok := stateDB.cachedContract[addr]; ok {
-		return contract.SetState(key, value[:])
+		err := contract.SetState(key, value[:])
+		if hex.EncodeToString(addr[:]) == "2a1da145442f98815d2f84a92b04465ad3074e86"{
+			root := contract.RootHash()
+			log.L().Warn("current contract state", zap.String("root", hex.EncodeToString(root[:])),
+				zap.String("key", hex.EncodeToString(key[:])), zap.String("value", hex.EncodeToString(value[:])))
+		}
+		return err
 	}
 	contract, err := stateDB.getContract(addr)
 	if err != nil {
@@ -571,16 +579,31 @@ func (stateDB *StateDBAdapter) setContractState(addr hash.Hash160, key, value ha
 
 // CommitContracts commits contract code to db and update pending contract account changes to trie
 func (stateDB *StateDBAdapter) CommitContracts() error {
-	for addr, contract := range stateDB.cachedContract {
+	addrStrs := make([]string, 0)
+	for addr := range stateDB.cachedContract {
+		addrStrs = append(addrStrs, hex.EncodeToString(addr[:]))
+	}
+	sort.Strings(addrStrs)
+
+	for _, addrStr := range addrStrs {
+		var addr hash.Hash160
+		addrBytes, err := hex.DecodeString(addrStr)
+		if err != nil {
+			return errors.Wrap(err, "failed to decode address hash")
+		}
+		copy(addr[:], addrBytes)
 		if _, ok := stateDB.suicided[addr]; ok {
 			// no need to update a suicide account/contract
 			continue
 		}
+		contract := stateDB.cachedContract[addr]
 		if err := contract.Commit(); err != nil {
 			stateDB.logError(err)
 			return errors.Wrap(err, "failed to commit contract")
 		}
 		state := contract.SelfState()
+		log.L().Warn("self state", zap.Uint64("nonce", state.Nonce), zap.Any("balance", state.Balance),
+			zap.String("root", hex.EncodeToString(state.Root[:])), zap.String("code hash", hex.EncodeToString(state.CodeHash)))
 		// store the account (with new storage trie root) into account trie
 		if err := stateDB.sm.PutState(addr, state); err != nil {
 			stateDB.logError(err)
@@ -588,14 +611,39 @@ func (stateDB *StateDBAdapter) CommitContracts() error {
 		}
 	}
 	// delete suicided accounts/contract
+	addrStrs = make([]string, 0)
 	for addr := range stateDB.suicided {
+		addrStrs = append(addrStrs, hex.EncodeToString(addr[:]))
+	}
+	sort.Strings(addrStrs)
+
+	for _, addrStr := range addrStrs {
+		var addr hash.Hash160
+		addrBytes, err := hex.DecodeString(addrStr)
+		if err != nil {
+			return errors.Wrap(err, "failed to decode address hash")
+		}
+		copy(addr[:], addrBytes)
 		if err := stateDB.sm.DelState(addr); err != nil {
 			stateDB.logError(err)
 			return errors.Wrapf(err, "failed to delete suicide account/contract %x", addr[:])
 		}
 	}
 	// write preimages to DB
-	for k, v := range stateDB.preimages {
+	addrStrs = make([]string, 0)
+	for addr := range stateDB.preimages {
+		addrStrs = append(addrStrs, hex.EncodeToString(addr[:]))
+	}
+	sort.Strings(addrStrs)
+
+	for _, addrStr := range addrStrs {
+		var k common.Hash
+		addrBytes, err := hex.DecodeString(addrStr)
+		if err != nil {
+			return errors.Wrap(err, "failed to decode address hash")
+		}
+		copy(k[:], addrBytes)
+		v := stateDB.preimages[k]
 		h := make([]byte, len(k))
 		copy(h, k[:])
 		stateDB.cb.Put(PreimageKVNameSpace, h, v, "failed to put hash %x preimage %x", k, v)
diff --git a/blockchain/blockchain.go b/blockchain/blockchain.go
index 166184c8..8ad37934 100644
--- a/blockchain/blockchain.go
+++ b/blockchain/blockchain.go
@@ -41,6 +41,7 @@ import (
 	"github.com/iotexproject/iotex-core/pkg/util/fileutil"
 	"github.com/iotexproject/iotex-core/state"
 	"github.com/iotexproject/iotex-core/state/factory"
+	"encoding/hex"
 )
 
 var (
@@ -924,6 +925,9 @@ func (bc *blockchain) pickAndRunActions(ctx context.Context, actionMap map[strin
 			receipts = append(receipts, receipt)
 		}
 		executedActions = append(executedActions, nextAction)
+		digest := ws.Digest()
+		h := nextAction.Hash()
+		log.L().Error("Delta digtest", zap.String("digtest", hex.EncodeToString(digest[:])), zap.String("action hash", hex.EncodeToString(h[:])))
 
 		// To prevent loop all actions in act_pool, we stop processing action when remaining gas is below
 		// than certain threshold
@@ -947,6 +951,9 @@ func (bc *blockchain) pickAndRunActions(ctx context.Context, actionMap map[strin
 				receipts = append(receipts, receipt)
 			}
 			executedActions = append(executedActions, putPollResult)
+			digest := ws.Digest()
+			h := putPollResult.Hash()
+			log.L().Error("Delta digtest", zap.String("digtest", hex.EncodeToString(digest[:])), zap.String("action hash", hex.EncodeToString(h[:])))
 		}
 	case errDelegatesNotExist:
 		if raCtx.BlockHeight == lastBlkHeight {
@@ -973,6 +980,9 @@ func (bc *blockchain) pickAndRunActions(ctx context.Context, actionMap map[strin
 		receipts = append(receipts, receipt)
 	}
 	executedActions = append(executedActions, grant)
+	digest := ws.Digest()
+	h := grant.Hash()
+	log.L().Error("Delta digtest", zap.String("digtest", hex.EncodeToString(digest[:])), zap.String("action hash", hex.EncodeToString(h[:])))
 
 	// Process grant epoch reward action if the block is the last one in an epoch
 	if raCtx.BlockHeight == lastBlkHeight {
@@ -988,6 +998,9 @@ func (bc *blockchain) pickAndRunActions(ctx context.Context, actionMap map[strin
 			receipts = append(receipts, receipt)
 		}
 		executedActions = append(executedActions, grant)
+		digest := ws.Digest()
+		h := grant.Hash()
+		log.L().Error("Delta digtest", zap.String("digtest", hex.EncodeToString(digest[:])), zap.String("action hash", hex.EncodeToString(h[:])))
 	}
 
 	return ws.UpdateBlockLevelInfo(raCtx.BlockHeight), receipts, executedActions, nil
diff --git a/consensus/consensusfsm/fsm.go b/consensus/consensusfsm/fsm.go
index 4ec69aec..08f7f80b 100644
--- a/consensus/consensusfsm/fsm.go
+++ b/consensus/consensusfsm/fsm.go
@@ -272,17 +272,11 @@ func (m *ConsensusFSM) produce(evt *ConsensusEvent, delay time.Duration) {
 			select {
 			case <-m.close:
 			case <-m.clock.After(delay):
-				if evt.eventType == eFailedToReceiveBlock {
-					log.L().Error("Produce fail to receive block event")
-				}
 				m.evtq <- evt
 			}
 			m.wg.Done()
 		}()
 	} else {
-		if evt.eventType == eReceiveBlock {
-			log.L().Error("Produce receive block event")
-		}
 		m.evtq <- evt
 	}
 }
@@ -303,7 +297,7 @@ func (m *ConsensusFSM) handle(evt *ConsensusEvent) error {
 	switch errors.Cause(err) {
 	case nil:
 		m.ctx.Logger().Debug(
-			"consensuls state transition happens",
+			"consensus state transition happens",
 			zap.String("src", string(src)),
 			zap.String("dst", string(m.fsm.CurrentState())),
 			zap.String("evt", string(evt.Type())),
diff --git a/consensus/scheme/rolldpos/rolldpos.go b/consensus/scheme/rolldpos/rolldpos.go
index d87ba194..01d2d275 100644
--- a/consensus/scheme/rolldpos/rolldpos.go
+++ b/consensus/scheme/rolldpos/rolldpos.go
@@ -148,8 +148,6 @@ func (r *RollDPoS) HandleConsensusMsg(msg *iotexrpc.Consensus) error {
 			return errors.Wrap(err, "failed to deserialize block")
 		}
 		log.L().Debug("receive block message", zap.Any("msg", block))
-		log.L().Error("receive block message", zap.Uint32("round", msg.Round), zap.Uint64("height", block.Height()), zap.Int("action number", len(block.Actions)))
-		log.L().Error("current round number", zap.Uint32("round", r.ctx.round.number))
 		// TODO: add proof of lock
 		if msg.Height != block.Height() {
 			return errors.Errorf(
diff --git a/db/batch.go b/db/batch.go
index f7a7067c..47661bae 100644
--- a/db/batch.go
+++ b/db/batch.go
@@ -14,6 +14,8 @@ import (
 	"github.com/pkg/errors"
 
 	"github.com/iotexproject/iotex-core/pkg/hash"
+	"go.uber.org/zap"
+	"encoding/hex"
 )
 
 type (
@@ -313,6 +315,7 @@ func (cb *cachedBatch) Digest() hash.Hash256 {
 		if err != nil {
 			log.S().Panic("Batch entry %d doesn't exist", i)
 		}
+		log.L().Error("Digest entry", zap.String("entry content", hex.EncodeToString(wi.serialize())), zap.Int("entry number", i))
 		bytes = append(bytes, wi.serialize()...)
 	}
 	return hash.Hash256b(bytes)
diff --git a/pkg/log/log.go b/pkg/log/log.go
index 6dc65bbb..b947f326 100644
--- a/pkg/log/log.go
+++ b/pkg/log/log.go
@@ -38,7 +38,7 @@ type GlobalConfig struct {
 func init() {
 	zapCfg := zap.NewDevelopmentConfig()
 	zapCfg.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
-	zapCfg.Level.SetLevel(zap.InfoLevel)
+	zapCfg.Level.SetLevel(zap.DebugLevel)
 	l, err := zapCfg.Build()
 	if err != nil {
 		log.Println("Failed to init zap global logger, no zap log will be shown till zap is properly initialized: ", err)
diff --git a/state/factory/statedb.go b/state/factory/statedb.go
index 5e649dae..6802249a 100644
--- a/state/factory/statedb.go
+++ b/state/factory/statedb.go
@@ -198,12 +198,12 @@ func (sdb *stateDB) CandidatesByHeight(height uint64) ([]*state.Candidate, error
 	// Load Candidates on the given height from underlying db
 	candidatesKey := candidatesutil.ConstructKey(height)
 	err := sdb.state(candidatesKey, &candidates)
-	log.L().Debug(
-		"CandidatesByHeight",
-		zap.Uint64("height", height),
-		zap.Any("candidates", candidates),
-		zap.Error(err),
-	)
+	//log.L().Debug(
+	//	"CandidatesByHeight",
+	//	zap.Uint64("height", height),
+	//	zap.Any("candidates", candidates),
+	//	zap.Error(err),
+	//)
 	if errors.Cause(err) == nil {
 		if len(candidates) > 0 {
 			return candidates, nil
diff --git a/state/factory/statetx.go b/state/factory/statetx.go
index 7669c017..dde5842c 100644
--- a/state/factory/statetx.go
+++ b/state/factory/statetx.go
@@ -18,6 +18,9 @@ import (
 	"github.com/iotexproject/iotex-core/pkg/hash"
 	"github.com/iotexproject/iotex-core/pkg/util/byteutil"
 	"github.com/iotexproject/iotex-core/state"
+	"github.com/iotexproject/iotex-core/pkg/log"
+	"go.uber.org/zap"
+	"encoding/hex"
 )
 
 // stateTX implements stateTX interface, tracks pending changes to account/contract in local cache
@@ -174,6 +177,7 @@ func (stx *stateTX) PutState(pkHash hash.Hash160, s interface{}) error {
 	if err != nil {
 		return errors.Wrapf(err, "failed to convert account %v to bytes", s)
 	}
+	log.L().Warn("Put state", zap.String("pkHash", hex.EncodeToString(pkHash[:])), zap.String("state", hex.EncodeToString(ss)))
 	stx.cb.Put(AccountKVNameSpace, pkHash[:], ss, "error when putting k = %x", pkHash)
 	return nil
 }
diff --git a/tools/executiontester/assetcontract/assetcontract.go b/tools/executiontester/assetcontract/assetcontract.go
index ace27771..a8a7062c 100644
--- a/tools/executiontester/assetcontract/assetcontract.go
+++ b/tools/executiontester/assetcontract/assetcontract.go
@@ -124,7 +124,7 @@ func deployContract(code string, chainEndPoint string) (string, error) {
 		return "", errors.Wrapf(err, "failed to deploy contract, txhash = %s", h)
 	}
 
-	time.Sleep(time.Second * 18)
+	time.Sleep(time.Second * 3)
 	receipt, err := contract.CheckCallResult(h)
 	if err != nil {
 		return "", errors.Wrapf(err, "failed to deploy contract, txhash = %s", h)
diff --git a/tools/executiontester/blockchain/fp_token.go b/tools/executiontester/blockchain/fp_token.go
index d9f33d72..b0bff1f3 100644
--- a/tools/executiontester/blockchain/fp_token.go
+++ b/tools/executiontester/blockchain/fp_token.go
@@ -15,6 +15,8 @@ import (
 
 	"github.com/iotexproject/iotex-core/address"
 	"github.com/iotexproject/iotex-core/pkg/hash"
+	"github.com/iotexproject/iotex-core/pkg/log"
+	"go.uber.org/zap"
 )
 
 const (
@@ -107,7 +109,7 @@ func (f *fpToken) CreateToken(id, debtor, creditor string, total, risk int64, op
 	if err != nil {
 		return h, errors.Wrapf(err, "failed to create fp token %s", id)
 	}
-	time.Sleep(time.Second * 5)
+	time.Sleep(time.Second * 30)
 	if _, err := f.CheckCallResult(h); err != nil {
 		return h, errors.Wrapf(err, "failed to create fp token %s", id)
 	}
@@ -192,6 +194,7 @@ func (f *fpToken) Transfer(token, sender, pubkey, prvkey, receiver string, amoun
 	if err != nil {
 		return h, errors.Wrap(err, "transfer failed")
 	}
+	log.L().Error("Sending fp token transfer", zap.String("action hash", h))
 	time.Sleep(time.Second * 3)
 	if _, err := f.CheckCallResult(h); err != nil {
 		return h, errors.Wrap(err, "transfer failed")
@@ -235,26 +238,32 @@ func (f *fpToken) Start() error {
 	if err != nil {
 		return errors.Errorf("invalid management contract address = %s", f.manage)
 	}
+	log.L().Warn("addrManage", zap.String("pkHash", hex.EncodeToString(addrManage.Bytes())))
 	addrProxy, err := address.FromString(f.manageProxy)
 	if err != nil {
 		return errors.Errorf("invalid management proxy contract address = %s", f.manageProxy)
 	}
+	log.L().Warn("addrProxy", zap.String("pkHash", hex.EncodeToString(addrProxy.Bytes())))
 	addrEap, err := address.FromString(f.eapStorage)
 	if err != nil {
 		return errors.Errorf("invalid storage contract address = %s", f.eapStorage)
 	}
+	log.L().Warn("addrEap", zap.String("pkHash", hex.EncodeToString(addrEap.Bytes())))
 	addrRiskLock, err := address.FromString(f.riskLock)
 	if err != nil {
 		return errors.Errorf("invalid risk lock contract address = %s", f.riskLock)
 	}
+	log.L().Warn("addrRiskLock", zap.String("pkHash", hex.EncodeToString(addrRiskLock.Bytes())))
 	addrReg, err := address.FromString(f.registry)
 	if err != nil {
 		return errors.Errorf("invalid registry contract address = %s", f.registry)
 	}
+	log.L().Warn("addrReg", zap.String("pkHash", hex.EncodeToString(addrReg.Bytes())))
 	addrCdp, err := address.FromString(f.cdp)
 	if err != nil {
 		return errors.Errorf("invalid cdp management contract address = %s", f.cdp)
 	}
+	log.L().Warn("addrCdp", zap.String("pkHash", hex.EncodeToString(addrCdp.Bytes())))
 	admin, err := address.FromString(Producer)
 	if err != nil {
 		return errors.Errorf("invalid admin address = %s", Producer)
@@ -383,7 +392,7 @@ func (f *fpToken) Start() error {
 		return errors.Wrap(err, "stable token contract failed to set approve")
 	}
 
-	time.Sleep(time.Second * 30)
+	time.Sleep(time.Second * 9)
 
 	if _, err := f.CheckCallResult(h); err != nil {
 		return errors.Wrap(err, "management contract failed to set storage")
diff --git a/tools/executiontester/blockchain/stable_token.go b/tools/executiontester/blockchain/stable_token.go
index 9880e352..3db4e367 100644
--- a/tools/executiontester/blockchain/stable_token.go
+++ b/tools/executiontester/blockchain/stable_token.go
@@ -256,7 +256,7 @@ func (s *stableToken) Start() error {
 		return errors.Wrap(err, "stable token contract failed to set global pause")
 	}
 
-	time.Sleep(time.Second * 20)
+	time.Sleep(time.Second * 6)
 	if _, err := s.CheckCallResult(h); err != nil {
 		return errors.Wrap(err, "allowance sheet failed to transfer ownership")
 	}
diff --git a/tools/executiontester/executiontester.go b/tools/executiontester/executiontester.go
index 9ee7dc30..a6ee5f41 100644
--- a/tools/executiontester/executiontester.go
+++ b/tools/executiontester/executiontester.go
@@ -46,7 +46,7 @@ func main() {
 	cfg.Plugins[config.GatewayPlugin] = true
 	cfg.Chain.EnableAsyncIndexWrite = false
 	cfg.Genesis.ActionGasLimit = 10000000
-	cfg.Genesis.BlockInterval = 2
+	cfg.Genesis.BlockInterval = 2 * time.Second
 	itxsvr, err := itx.NewServer(cfg)
 	if err != nil {
 		log.L().Fatal("Failed to start itxServer.", zap.Error(err))
@@ -63,19 +63,28 @@ func main() {
 	}
 
 	// Create two accounts
-	debtorPubKey, debtorPriKey, debtorAddr, err := createAccount()
-	if err != nil {
-		log.L().Fatal("Failed to create account.", zap.Error(err))
-	}
-	_, _, creditorAddr, err := createAccount()
-	if err != nil {
-		log.L().Fatal("Failed to create account.", zap.Error(err))
-	}
+	//debtorPubKey, debtorPriKey, debtorAddr, err := createAccount()
+	//if err != nil {
+	//	log.L().Fatal("Failed to create account.", zap.Error(err))
+	//}
+	//_, _, creditorAddr, err := createAccount()
+	//if err != nil {
+	//	log.L().Fatal("Failed to create account.", zap.Error(err))
+	//}
+	debtorPubKey := "045c140600209d9d0860bb88aeb3c25d60058de3edaefef2b3c7ec601aa98cf3c6c9b8117354f99219779cbcc8cd78534ddc34bfb253920eb138994b902b9ec19d"
+	debtorPriKey := "712353f1e18b3901ce2f7f1b2b045af621d7c2b6d529385849385f24f5d9953f"
+	debtorAddr := "io1crl7nek497h5lmj8qy97dxlfegmrev7cqwtlup"
+	creditorAddr := "io1ygj3q0xcm3rm639k75u3wqhtcts7t8w2gxj2s4"
+
 
 	// Create fp token
-	assetID := assetcontract.GenerateAssetID()
-	open := strconv.Itoa(int(time.Now().UnixNano() / 1e6))
-	exp := strconv.Itoa(int(time.Now().UnixNano()/1e6 + 1000000))
+	//assetID := assetcontract.GenerateAssetID()
+	//open := strconv.Itoa(int(time.Now().UnixNano() / 1e6))
+	//exp := strconv.Itoa(int(time.Now().UnixNano()/1e6 + 1000000))
+	assetID := "2019031938960305"
+	open := "1553060435132"
+	exp := "1553061435132"
+
 
 	if _, err := fpToken.CreateToken(assetID, debtorAddr, creditorAddr, total, risk, open, exp); err != nil {
 		log.L().Fatal("Failed to create fp token", zap.Error(err))
@@ -85,12 +94,17 @@ func main() {
 	if err != nil {
 		log.L().Fatal("Failed to get token contract address", zap.Error(err))
 	}
+	log.L().Error("fp token contract address", zap.String("address", contractAddr))
+
+	log.L().Error("Start here.................")
 
 	// Transfer fp token
 	if _, err := fpToken.Transfer(contractAddr, debtorAddr, debtorPubKey, debtorPriKey, creditorAddr, transfer); err != nil {
 		log.L().Fatal("Failed to transfer fp token from debtor to creditor", zap.Error(err))
 	}
 
+	log.L().Error("End here...................")
+
 	debtorBalance, err := fpToken.ReadValue(contractAddr, "70a08231", debtorAddr)
 	if err != nil {
 		log.L().Fatal("Failed to get debtor's asset balance.", zap.Error(err))
diff --git a/tools/minicluster/minicluster.go b/tools/minicluster/minicluster.go
index e80df542..54f21b66 100644
--- a/tools/minicluster/minicluster.go
+++ b/tools/minicluster/minicluster.go
@@ -215,6 +215,8 @@ func main() {
 
 		expectedBalancesMap := util.GetAllBalanceMap(client, chainAddrs)
 
+		log.L().Info("Start action injections.")
+
 		wg := &sync.WaitGroup{}
 		util.InjectByAps(wg, aps, counter, transferGasLimit, transferGasPrice, transferPayload, voteGasLimit,
 			voteGasPrice, contract, executionAmount, executionGasLimit, executionGasPrice, interactExecData, fpToken,
@@ -294,13 +296,13 @@ func main() {
 		if err != nil {
 			log.S().Error("Failed to get debtor's asset balance.", zap.Error(err))
 		}
-		log.S().Info("Debtor's asset balance: ", zap.Int64("balance", debtorBalance))
+		log.L().Info("Debtor's asset balance: ", zap.Int64("balance", debtorBalance))
 
 		creditorBalance, err := fpToken.ReadValue(fpContract, "70a08231", creditor.EncodedAddr)
 		if err != nil {
 			log.S().Error("Failed to get creditor's asset balance.", zap.Error(err))
 		}
-		log.S().Info("Creditor's asset balance: ", zap.Int64("balance", creditorBalance))
+		log.L().Info("Creditor's asset balance: ", zap.Int64("balance", creditorBalance))
 
 		if debtorBalance+creditorBalance != fpTotal {
 			log.S().Error("Sum of asset balance is incorrect.")
@@ -335,7 +337,7 @@ func newConfig(
 
 	cfg.Consensus.Scheme = config.RollDPoSScheme
 	cfg.Consensus.RollDPoS.FSM.UnmatchedEventInterval = 2400 * time.Millisecond
-	cfg.Consensus.RollDPoS.FSM.AcceptBlockTTL = 5000 * time.Millisecond
+	cfg.Consensus.RollDPoS.FSM.AcceptBlockTTL = 1800 * time.Millisecond
 	cfg.Consensus.RollDPoS.FSM.AcceptProposalEndorsementTTL = 1800 * time.Millisecond
 	cfg.Consensus.RollDPoS.FSM.AcceptLockEndorsementTTL = 1800 * time.Millisecond
 	cfg.Consensus.RollDPoS.FSM.EventChanSize = 100000
diff --git a/tools/util/injectorutil.go b/tools/util/injectorutil.go
index 8b37d93a..31c85f35 100644
--- a/tools/util/injectorutil.go
+++ b/tools/util/injectorutil.go
@@ -136,6 +136,7 @@ func InjectByAps(
 	if fpToken == nil {
 		randRange = 2
 	}
+	randRange = 1
 loop:
 	for {
 		select {
@@ -178,7 +179,7 @@ loop:
 			wg.Add(1)
 			//TODO Currently Vote is skipped because it will fail on balance test and is planned to be removed
 			switch randNum := rand.Intn(randRange); randNum {
-			case 0:
+			case 2:
 				sender, recipient, nonce, amount := createTransferInjection(counter, delegates)
 				if err := updateTransferExpectedBalanceMap(
 					expectedBalances,
@@ -216,7 +217,7 @@ loop:
 				go injectExecInteraction(wg, client, executor, contract, nonce, big.NewInt(int64(executionAmount)),
 					uint64(executionGasLimit), big.NewInt(int64(executionGasPrice)),
 					executionData, retryNum, retryInterval)
-			case 2:
+			case 0:
 				go injectFpTokenTransfer(wg, fpToken, fpContract, debtor, creditor)
 			}
 		}
