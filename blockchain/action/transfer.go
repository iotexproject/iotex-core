// Copyright (c) 2018 IoTeX
// This is an alpha (internal) release and is not suitable for production. This source code is provided 'as is' and no
// warranties are given as to title or non-infringement, merchantability or fitness for purpose and, to the extent
// permitted by law, all liability for your use of the code is disclaimed. This source code is governed by Apache
// License 2.0 that can be found in the LICENSE file.

package action

import (
	"bytes"
	"encoding/hex"
	"math/big"

	"github.com/golang/protobuf/proto"
	"github.com/pkg/errors"
	"golang.org/x/crypto/blake2b"

	"github.com/iotexproject/iotex-core/crypto"
	"github.com/iotexproject/iotex-core/explorer/idl/explorer"
	"github.com/iotexproject/iotex-core/iotxaddress"
	"github.com/iotexproject/iotex-core/logger"
	"github.com/iotexproject/iotex-core/pkg/enc"
	"github.com/iotexproject/iotex-core/pkg/hash"
	"github.com/iotexproject/iotex-core/pkg/keypair"
	"github.com/iotexproject/iotex-core/pkg/version"
	"github.com/iotexproject/iotex-core/proto"
)

var (
	// ErrTransferError indicates error for a transfer action
	ErrTransferError = errors.New("transfer error")
	// ErrAddr indicates error of address
	ErrAddr = errors.New("address error")
)

// versionSizeInBytes defines the size of version in byte units
const versionSizeInBytes = 4

type (
	// Transfer defines the struct of account-based transfer
	Transfer struct {
		Version uint32

		Nonce           uint64
		Amount          *big.Int
		Sender          string
		Recipient       string
		Payload         []byte
		SenderPublicKey keypair.PublicKey
		Signature       []byte
		IsCoinbase      bool
		// Coinbase transfer is not expected to be received from the network but can only be generated by block producer
	}
)

// NewTransfer returns a Transfer instance
func NewTransfer(nonce uint64, amount *big.Int, sender string, recipient string) (*Transfer, error) {
	if len(sender) == 0 || len(recipient) == 0 {
		return nil, errors.Wrap(ErrAddr, "address of sender or recipient is empty")
	}

	return &Transfer{
		Version: version.ProtocolVersion,

		Nonce:     nonce,
		Amount:    amount,
		Sender:    sender,
		Recipient: recipient,
		// Payload is empty for now
		Payload:    []byte{},
		IsCoinbase: false,
		// SenderPublicKey and Signature will be populated in Sign()
	}, nil
}

// NewCoinBaseTransfer returns a coinbase Transfer
func NewCoinBaseTransfer(amount *big.Int, recipient string) *Transfer {
	return &Transfer{
		Version:   version.ProtocolVersion,
		Amount:    amount,
		Recipient: recipient,
		// Payload is empty for now
		Payload:    []byte{},
		IsCoinbase: true,
		// SenderPublicKey and Signature will be populated in Sign()
	}
}

// TotalSize returns the total size of this Transfer
func (tsf *Transfer) TotalSize() uint32 {
	size := versionSizeInBytes
	// add nonce, amount, sender, receipt, and payload sizes
	size += NonceSizeInBytes
	size += BooleanSizeInBytes
	if tsf.Amount != nil && len(tsf.Amount.Bytes()) > 0 {
		size += len(tsf.Amount.Bytes())
	}
	size += len(tsf.Sender)
	size += len(tsf.Recipient)
	size += len(tsf.Payload)
	size += len(tsf.SenderPublicKey)
	size += len(tsf.Signature)
	return uint32(size)
}

// ByteStream returns a raw byte stream of this Transfer
func (tsf *Transfer) ByteStream() []byte {
	stream := make([]byte, 4)
	enc.MachineEndian.PutUint32(stream, tsf.Version)
	temp := make([]byte, 8)
	enc.MachineEndian.PutUint64(temp, tsf.Nonce)
	stream = append(stream, temp...)
	if tsf.Amount != nil && len(tsf.Amount.Bytes()) > 0 {
		stream = append(stream, tsf.Amount.Bytes()...)
	}
	stream = append(stream, tsf.Sender...)
	stream = append(stream, tsf.Recipient...)
	stream = append(stream, tsf.Payload...)
	stream = append(stream, tsf.SenderPublicKey[:]...)
	// Signature = Sign(hash(ByteStream())), so not included
	if tsf.IsCoinbase {
		stream = append(stream, 1)
	} else {
		stream = append(stream, 0)
	}
	return stream
}

// ConvertToActionPb converts Transfer to protobuf's ActionPb
func (tsf *Transfer) ConvertToActionPb() *iproto.ActionPb {
	// used by account-based model
	t := &iproto.ActionPb{
		Action: &iproto.ActionPb_Transfer{
			Transfer: &iproto.TransferPb{
				Sender:       tsf.Sender,
				Recipient:    tsf.Recipient,
				Payload:      tsf.Payload,
				SenderPubKey: tsf.SenderPublicKey[:],
				IsCoinbase:   tsf.IsCoinbase,
			},
		},
		Version:   tsf.Version,
		Nonce:     tsf.Nonce,
		Signature: tsf.Signature,
	}

	if tsf.Amount != nil && len(tsf.Amount.Bytes()) > 0 {
		t.GetTransfer().Amount = tsf.Amount.Bytes()
	}
	return t
}

// ToJSON converts Transfer to TransferJSON
func (tsf *Transfer) ToJSON() *explorer.Transfer {
	// used by account-based model
	t := &explorer.Transfer{
		Version:      int64(tsf.Version),
		Nonce:        int64(tsf.Nonce),
		Sender:       tsf.Sender,
		Recipient:    tsf.Recipient,
		Payload:      hex.EncodeToString(tsf.Payload),
		SenderPubKey: keypair.EncodePublicKey(tsf.SenderPublicKey),
		Signature:    hex.EncodeToString(tsf.Signature),
		IsCoinbase:   tsf.IsCoinbase,
	}

	if tsf.Amount != nil && len(tsf.Amount.Bytes()) > 0 {
		t.Amount = tsf.Amount.Int64()
	}
	return t
}

// Serialize returns a serialized byte stream for the Transfer
func (tsf *Transfer) Serialize() ([]byte, error) {
	return proto.Marshal(tsf.ConvertToActionPb())
}

// ConvertFromActionPb converts a protobuf's ActionPb to Transfer
func (tsf *Transfer) ConvertFromActionPb(pbAct *iproto.ActionPb) {
	// set trnx fields
	tsf.Version = pbAct.GetVersion()
	// used by account-based model
	tsf.Nonce = pbAct.Nonce
	if tsf.Amount == nil {
		tsf.Amount = big.NewInt(0)
	}

	pbTsf := pbAct.GetTransfer()
	if len(pbTsf.Amount) > 0 {
		tsf.Amount.SetBytes(pbTsf.Amount)
	}
	tsf.Sender = ""
	if len(pbTsf.Sender) > 0 {
		tsf.Sender = string(pbTsf.Sender)
	}
	tsf.Recipient = ""
	if len(pbTsf.Recipient) > 0 {
		tsf.Recipient = string(pbTsf.Recipient)
	}
	tsf.Payload = nil
	tsf.Payload = pbTsf.Payload
	copy(tsf.SenderPublicKey[:], pbTsf.SenderPubKey)
	tsf.Signature = nil
	tsf.Signature = pbAct.Signature
	tsf.IsCoinbase = pbTsf.IsCoinbase
}

// NewTransferFromJSON creates a new Transfer from TransferJSON
func NewTransferFromJSON(jsonTsf *explorer.Transfer) (*Transfer, error) {
	tsf := &Transfer{}
	tsf.Version = uint32(jsonTsf.Version)
	// used by account-based model
	tsf.Nonce = uint64(jsonTsf.Nonce)
	tsf.Amount = big.NewInt(jsonTsf.Amount)
	tsf.Sender = jsonTsf.Sender
	tsf.Recipient = jsonTsf.Recipient
	payload, err := hex.DecodeString(jsonTsf.Payload)
	if err != nil {
		logger.Error().Err(err).Msg("Fail to create a new Transfer from TransferJSON")
		return nil, err
	}
	tsf.Payload = payload
	senderPubKey, err := keypair.StringToPubKeyBytes(jsonTsf.SenderPubKey)
	if err != nil {
		logger.Error().Err(err).Msg("Fail to create a new Transfer from TransferJSON")
		return nil, err
	}
	copy(tsf.SenderPublicKey[:], senderPubKey)
	signature, err := hex.DecodeString(jsonTsf.Signature)
	if err != nil {
		logger.Error().Err(err).Msg("Fail to create a new Transfer from TransferJSON")
		return nil, err
	}
	tsf.Signature = signature
	tsf.IsCoinbase = jsonTsf.IsCoinbase

	return tsf, nil
}

// Deserialize parse the byte stream into Transfer
func (tsf *Transfer) Deserialize(buf []byte) error {
	pbAct := &iproto.ActionPb{}
	if err := proto.Unmarshal(buf, pbAct); err != nil {
		return err
	}
	tsf.ConvertFromActionPb(pbAct)
	return nil
}

// Hash returns the hash of the Transfer
func (tsf *Transfer) Hash() hash.Hash32B {
	hash := blake2b.Sum256(tsf.ByteStream())
	return blake2b.Sum256(hash[:])
}

// Sign signs the Transfer using sender's private key
func (tsf *Transfer) Sign(sender *iotxaddress.Address) (*Transfer, error) {
	// check the sender is correct
	if tsf.Sender != sender.RawAddress {
		return nil, errors.Wrapf(ErrTransferError, "signing addr %s does not match with Transfer addr %s",
			sender.RawAddress, tsf.Sender)
	}
	// check the public key is actually owned by sender
	pkhash, err := iotxaddress.GetPubkeyHash(sender.RawAddress)
	if err != nil {
		return nil, errors.Wrap(err, "error when getting the pubkey hash")
	}
	if !bytes.Equal(pkhash, keypair.HashPubKey(sender.PublicKey)) {
		return nil, errors.Wrapf(ErrTransferError, "signing addr %s does not own correct public key",
			sender.RawAddress)
	}
	tsf.SenderPublicKey = sender.PublicKey
	if err := tsf.sign(sender); err != nil {
		return nil, err
	}
	return tsf, nil
}

// Verify verifies the Transfer using sender's public key
func (tsf *Transfer) Verify(sender *iotxaddress.Address) error {
	hash := tsf.Hash()
	if success := crypto.EC283.Verify(sender.PublicKey, hash[:], tsf.Signature); success {
		return nil
	}
	return errors.Wrapf(ErrTransferError, "Failed to verify Transfer signature = %x", tsf.Signature)
}

//======================================
// private functions
//======================================

func (tsf *Transfer) sign(sender *iotxaddress.Address) error {
	hash := tsf.Hash()
	if tsf.Signature = crypto.EC283.Sign(sender.PrivateKey, hash[:]); tsf.Signature != nil {
		return nil
	}
	return errors.Wrapf(ErrTransferError, "Failed to sign Transfer hash = %x", hash)
}
